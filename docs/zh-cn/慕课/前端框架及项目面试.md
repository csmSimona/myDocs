# 前端框架及项目面试

## 面试题

### Vue面试题

- v-show和v-if的区别
- 为何v-for中要用key
- 描述Vue组件生命周期（有父子组件的情况）
- Vue组件如何通讯
- 描述组件渲染和更新的过程
- 双向数据绑定v-model的实现原理

### react面试题

- react组件如何通讯

- JSX本质是什么

- context是什么，有何用途

- shouldComponentUpdate的用途

- 描述redux单向数据流

- setState是同步还是异步（场景见下图）  0 0 1 2 ？

  ![](..\picture\setState异步.png)

### 框架综合应用

- 基于react设计一个todolist（组件结构，redux state数据结构）
- 基于Vue设计一个购物车（组件结构，Vuex state数据结构）

### webpack面试题

- 前端代码为何要进行构建和打包
- module chunk bundle 分别是什么意思，有何区别
- loader和plugin的区别
- webpack如何实现懒加载
- webpack常见性能优化
- babel-runtime和babel-polyfill的区别

## Vue使用

### Vue基本使用

- 插值表达式

- 指令、动态属性

- v-html：会有XSS风险，会覆盖子组件（可以使用`<pre>`标签）

- computed和watch

  - computed有缓存，data不变则不会重新计算

  - watch如何深度监听？

    ```js
    watch: {
        // 普通监听
        name(oldVal, val){
            console.log(oldVal)
        },
        firstName: {
            handler(newName, oldName) {
                this.fullName = newName + ' ' + this.lastName;
            },
            // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法
            immediate: true,  	// 是否最初绑定的时候就执行
            deep: true 			// 是否深度监听
        }
    }
    ```

    `deep`的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改`obj`里面任何一个属性都会触发这个监听器里的 handler。

    优化，我们可以是使用字符串形式监听。

    ```js
    watch: {
      'obj.a': {
        handler(newName, oldName) {
          console.log('obj.a changed');
        },
        immediate: true,
        // deep: true
      }
    }
    ```

  - watch监听引用类型，拿不到oldVal

- class和style

  - 使用动态属性
  - 使用驼峰式写法

- 条件渲染

  - v-if v-else 的用法，可使用变量，也可以使用 === 表达式
  - v-if 和 v-show 的区别？
  - v-if 和 v-show 的使用场景？数据改变频繁用 v-show

- 列表渲染

  - 如何遍历对象？也可以用v-for

  - key的重要性，key不能乱写（如random或者index）

  - v-for 和 v-if 不能一起使用

    v-for比v-if的优先级更高，这就说明在v-for的每次循环运行中每一次都会调用v-if的判断，所以不推荐v-if和v-for在同一个标签内同时使用。
    
    解决方法：过滤一个列表中的项目 (比如 v-for=“user in users” v-if=“user.isActive”)。在这种情形下，请将 users替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表

- 事件

  - event参数，自定义参数

    1.event是原生的event对象，没有经过任何的装饰

    2.事件被挂载到当前元素

  - 事件修饰符

    ```vue
    <!-- 阻止单击事件继续传播 -->
    <a v-on:click.stop="doThis"></a>
    <!-- 提交事件不再重载页面 -->
    <form v-on:submit.prevent="onSubmit"></form>
    <!-- 修饰符可以串联 -->
    <a v-on:click.stop.prevent="doThat"></a>
    <!-- 只有修饰符 -->
    <form v-on:submit.prevent></form>
    <!-- 添加事件监听器时使用事件捕获模式 -->
    <!-- 事件捕获：事件从最不精确的对象(document对象)开始触发，然后到最精确 -->
    <div v-on:click.capture="doThis">...</div>
    <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
    <!-- 即事件不是从内部元素触发的 -->
    <div v-on:click.self="doThat">...</div>
    ```

  - 按键修饰符

    ```vue
    <!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
    <button @click.ctrl="onClick">A</button>
    <!-- 有且只有 Ctrl 被按下的时候才触发 -->
    <button @click.ctrl.exact="onCtrlClick">A</button>
    <!-- 没有任何系统修饰符被按下的时候才触发 -->
    <button @click.exact="onCtrlClick">A</button>
    ```

  - 【观察】事件 被绑定到哪里？

- 表单

  - v-model

    `<textarea v-model="desc"></textarea>`

    注意：`<textarea>{{desc}}</textarea>`是不允许的

  - 常见的表单项 textarea checkbox radio select

  - 修饰符 lazy number trim （v-model.lazy、v-model.number、v-model.trim）
  
    - 在输入框中，v-model 默认是同步数据，使用 **.lazy** 会转变为在 change 事件中同步 ， 也就是在**失去焦点 或者 按下回车键时才更新**
    - **.number 修饰符可以将 输入的值转化为Number类型** ，否则虽然你输入的是数字 但它的类型其实是String，在数字输入框中比较有用
    - **.trim** 修饰符会自动过滤掉输入的**首尾空格**

### Vue组件使用

- props 和 $emit（父子组件之间的通讯）

  ```js
  props: {
      list: {
          type: Array,
          default() {
              return []
          }
      }
  }
  ```
  ```js
  this.$emit(事件方法, 值)
  ```

- 组件间通讯 - 自定义事件（组件之间没有关系或者层级比较深）

  ```js
  import event from './event.js'
  event.$emit(事件方法, 值)
  ```
  ```js
  // 及时解绑自定义事件
  beforeDestory() {
      // 及时销毁，否则可能造成内存泄漏
      event.$off('onAddTitle', this.addTitleHandler)
  }
  ```

  event.js

  ```js
  import Vue from 'vue'
  
  export default new Vue()
  ```

  

- 组件生命周期

  - 单个组件

    created  页面还没开始渲染，但Vue实例已经初始化完成

    mounted  页面渲染完成  基本情况在mounted中进行操作，如ajax获取信息，绑定事件等

    beforeDestroy  解除绑定，销毁子组件以及事件监听器，如自定义事件，setTimeout，window、document事件

  - 父子组件

    父组件先开始初始化，再子组件初始化，子组件渲染完成后，父组件才渲染完成

    index created

    list created

    list mounted

    index mounted

    父组件先开始进入更新状态，再子组件，子组件更新完成后，父组件才更新完成

    index beforeUpdate

    list beforeUpdate

    list updated

    index updated

    销毁destroy同理

### Vue高级特性

- 自定义组件 v-model（如颜色选择）

  index.vue

  ```vue
  <template>
      <p>{{name}}</p>
      <CustomVModel v-model="name" />
  </templete>
  <script>
  import CustomVModel from './CustomVModel'
  export default{
  	components: {
      	CustomVModel
  	},
      data() {
          return() {
              name: 'csm'
          }
      }
  }
  </script>
  ```

  CustomVModel.Vue

  ```vue
  <template>
      <!--	
          注意：
          1.input使用:value而不是v-model
          2.change和model.event要对应起来
          3.content属性对应起来（model里面定义的prop对应props里面的属性）
      -->
      <input type="text" :value="content" @input="$emit('change', $event.target.value)">
  </templete>
  <script>
  export default{
  	model: {
      	prop: 'content',
          event: 'change'
  	},
      props:{
          content: String,
          default() {
              return ''
          }
      }
  }
  </script>
  ```

- $nextTick，ref

  - Vue是异步渲染
  - data改变之后，DOM不会立刻渲染
  - $nextTick会在DOM渲染之后被触发，以获取最新DOM节点

  ```vue
  <template>
  	<div>
          <ul ref="ul1">
              <li v-for="(item, index) in list" :key="index">{{item}}</li>
          </ul>
          <button @click="addItem">
              添加一项
          </button>
      </div>
  </template>
  <script>
      data() {
          return {
              list: ['a', 'b', 'c']
          }
      },
          methods: {
              addItem() {
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  // 1.异步渲染，$nextTick待DOM渲染完后再回调
                  // 2.页面渲染时会将data的修改做整合，多次data修改只会渲染一次
                  this.$nextTick(() => {
                      const ulElem = this.$refs.ul1
                      console.log(ulElem.childNodes.length)   
                      // 点击后 6，如果没有$nextTick是3
                  })
              }
          }
  </script>
  ```

- slot

  没有插槽的情况下在组件标签内写一些内容是不起任何作用的，当在组件中声明了slot元素后，在组件元素内写的内容就会替换slot。

  用于父组件中往子组件中插入一段内容。

  - 基本使用

    index.vue

    ```vue
    <template>
    	<SlotDemo :url="website.url">
        	{{website.title}}
        </SlotDemo>
    </template>
    <script>
    import SlotDemo from './SlotDemo'
    export default {
        components: {
            SlotDemo
        },
        data() {
            return {
                website: {
                    url: 'http://imooc.com/',
                    title: 'imooc',
                    subTitle: '程序员的梦工厂'
                }
            }
        }
    }
    </script>
    ```

    SlotDemo.vue

    ```vue
    <template>
    	<a :href="url">
            <slot>
                默认内容，即父组件没设置内容时，这里显示
            </slot>
        </a>
    </template>
    ```

  - 作用域插槽

    作用域插槽的主要作用是在书写插槽内容时可以获取到插槽作用域的值 

    index.Vue

    ```vue
    <template>
    	<ScopedSlotDemo :url="website.url">
        	<template v-slot="slotProps">
                <!-- slotProps.slotData 等于 子组件中的website -->
    			{{slotProps.slotData.title}}
    		</template>
        </ScopedSlotDemo>
    </template>
    <script>
    import ScopedSlotDemo from './ScopedSlotDemo'
    export default {
        components: {
            ScopedSlotDemo
        },
        data() {
            return {
                website: {
                    url: 'http://imooc.com/',
                    title: 'imooc',
                    subTitle: '程序员的梦工厂'
                }
            }
        }
    }
    </script>
    ```

    ScopedSlotDemo

    ```vue
    <template>
        <a :href="url">
            <slot :slotData="website">
                {{website.subTitle}} <!-- 默认值显示 subTitle ，即父组件不传内容时 -->
            </slot>
        </a>
    </template>
    
    <script>
    export default {
        props: ['url'],
        data() {
            return {
                website: {
                    url: 'http://wangEditor.com/',
                    title: 'wangEditor',
                    subTitle: '轻量级富文本编辑器'
                }
            }
        }
    }
    </script>
    ```

  - 具名插槽

    index.Vue

    ```vue
    <template>
    	<NamedSlot>
            <!-- 缩写 <template #header> -->
            <template v-slot:header>
            	<h1>将插入header slot中</h1>
            </template>
    		<p>将插入到main slot中，即未命名的slot</p>
    		<template v-slot:footer>
            	<h1>将插入footer slot中</h1>
            </template>
        </NamedSlot>
    </template>
    ```

    NamedSlot.Vue

    ```vue
    <template>
    	<div>
            <header>
            	<slot name="header"></slot>
            </header>
            <main>
            	<slot></slot>
            </main>
            <footer>
            	<slot name="footer"></slot>
            </footer>
        </div>
    </template>
    ```

- 动态组件

  - 用法 `<component :is="component-name" />`  传组件名
  - 需要根据数据，动态渲染的场景，如常见的有文本，视频，图片组件的新闻详情页。即组件类型不确定。
  - 每次都会销毁和重建，为了性能优化，也可以使用keep-alive缓存

- 异步组件

  - import()函数

    同步引入组件：`import formDemo from './formDemo'`

    异步引入组件：

    ```vue
    components:{
    	formDemo: () => import('./formDemo')
    }
    ```

  - 按需加载，异步加载大组件

- keep-alive

  ```vue
  <keep-alive>
  	<KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
  </keep-alive>
  ```

  - 缓存组件

  - 频繁切换，不需要重复渲染，用于tab切换等

  - Vue常见性能优化

  - v-show和keep-alive的区别：

    v-show是在css层面，控制元素的显示方式，将display属性在block和none来回切换；

    keep-alive是vue中的一个抽象组件，用于保存组件的渲染状态。

  ```vue
  <keep-alive :include="whiteList" :exclude="blackList" :max="amount">
      <router-view></router-view>
  </keep-alive>
  ```

  **include**定义缓存白名单，keep-alive会缓存命中的组件；**exclude**定义缓存黑名单，被命中的组件将不会被缓存；**max**定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。

  > [内存管理](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F5633616)的一种页面置换算法，对于在内存中但又不用的[数据块](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%95%B0%E6%8D%AE%E5%9D%97%2F107672)（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。

- mixin

  mixin.js

  ```js
  export default {
      data() {
          return {
              city: ''
          }
      },
      methods: {
          showName() {
              console.log(this.name)
          }
      }
  }
  ```

  index.Vue

  ```vue
  <script>
  import myMixin from './mixin'
  export default {
      mixins: [myMixin], // 可以添加多个，会自动合并起来
      data() {
          return {
              name: ''
          }
      },
      methods: {
      }
  }
  </script>
  ```

  - 多个组件有相同逻辑，抽离出来
  - mixin并不是完美的解决方案，会有一些问题
    - 变量来源不明确，不利于阅读
    - 多mixin可能造成命名冲突
    - mixin和组件可能出现多对多的关系，复杂度较高
  - Vue3提出的Composition API旨在解决这些问题

### Vuex使用

- 用于Vue组件

  - dispatch
  - commit
  - mapState
  - mapGetters
  - mapActions
  - mapMutations

- actions中才能做异步操作，不能在mutations中做

  ![vux过程](..\picture\vux过程.png)

### Vue-router使用

- 路由模式（hash，H5 history）

  - hash模式（默认），如 http://abc.com/#/user/10
  - H5 history模式，如 http://abc.com/user/20
  - 后者需要server端支持，因此无特殊需求可选择前者

- 路由配置（动态路由，懒加载）

  - 动态路由

    ```js
    const User = {
        template: '<div>User {{ $route.params.id }}</div>'
    }
    
    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头 能命中'/user/20','/user/10'等格式的路由
            { path: '/user/:id', components: User }
        ]
    })
    ```

  - 懒加载

    ```js
    const router = new VueRouter({
        routes: [
            { 
                path: '/user/:id', 
                // 异步加载组件
                components: () => import('./../components/Navigator')
            }
        ]
    })
    ```

    

## Vue原理

### 组件化基础

- “很久以前”就有组件化
- 数据驱动视图（MVVM，setState）

### 响应式

- 组件data的数据一旦变化，立刻触发视图更新

- 核心API - Object.defineProperty

  - 基本用法

    `Object.defineProperty(obj, props, descriptor)`
  
    作用： 在对象上定义一个新属性或者修改原有属性
  
    返回值： 修改后的目标对象obj
  
    参数定义：
  
    - obj: 在其上定义或修改属性的目标对象
  
  
    - props: 属性名称
  

    - descriptor: 属性描述符
  
  
    ```js
    const data = {}
    const name = 'zhangsan'
    Object.defineProperty(data, "name", {
        get: function() {
            console.log('get')
            return name
        },
        set: function() {
            console.log('set')
            name = newVal
        }
    })
    
    // 测试
  console.log(data.name) // get zhangsan
    data.name = 'lisi'     // set
    ```
  
  - 如何深度监听data变化（简单实现）
  
    ```js
    function updateView() {
        console.log('视图更新')
    }
    function defineReactive(target, key, value) {
        // 深度监听
        observe(value)
        // 核心API
        Object.defineProperty(target, key, {
            get() {
                return value
            },
            set(newValue) {
                if (newValue !== value) {
                    // 设置新值
                    observe(newValue)
                    value = newValue
                    // 触发更新视图
                    updateView()
                }
            }
        })
    }
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            // 不是对象或数组
            return target
        }
        // 重新定义各个熟悉（for in也可以遍历数组）
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    
    const data = {
        name: 'zhangsan',
        age: 20,
        info: {
            address: 'beijing' // 需要深度监听
        }
    }
    
    data.info.address = 'shanghai'
    ```
  
  - 如何监听数组变化
  
    ```js
    // 重新定义数组原型
    
    const oldArrayProperty = Array.propertype;
    // 创建新对象，原型指向oldArrayProperty，再扩展新的方法不会影响原型
    const arrProto = Object.create(oldArrayProperty);
    
    // 比如 这个新对象有push方法，则先实现他自己定义的push方法
    // 然后再处理原型数组的push方法  
    // 即 Array.prototype.push(this, ...arguments)
    ['push', 'pop', 'shift', 'splice'].forEach(methodName => {
        arrProto[methodName] = function () {
            updateView() //触发视图更新
            // 再去实现原型数组中对应的方法
            oldArrayProperty[methodName].call(this, ...arguments)
        }
    })
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            return target
        }
        // 监听数组
        if (Array.isArray(target)) {
            target.__proto__ = arrProto
        }
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    ```
  
  - 一些缺点（Vue3.0启用Proxy）
  
    - 深度监听需要递归到底，一次性计算量大
    - 无法监听新增/删除属性（因此出现 Vue.set Vue.delete 来弥补该缺点）
    - 无法原生监听数组，需要特殊处理
  
  - Proxy有兼容性问题，且无法polyfill

### vdom（虚拟dom）和diff

（[react基础](../前端基础汇总/react基础)中有写react相关虚拟dom和diff算法）

- vdom是实现vue和React的重要基石
- diff算法是vdom中最核心、最关键的部分

#### vdom

用JS模拟DOM结构，计算出更小的变更，操作DOM（具体可以看 react基础 中  虚拟DOM  这一节）

##### 用js模拟DOM结构

```html
<!-- DOM结构 -->
<div id="div1" class="container">
    <p>
        vdom
    </p>
    <ul style="font-size: 20px;">
        <li>a</li>
    </ul>
</div>
```

```js
// js模拟
{
    tag: 'div',
    props: {
        className: 'container',
        id: 'div1'
    },
    children: [
        {
            tag: 'p',
            children: 'vdom'
        }, {
            tag: 'ul',
            props: {
                style: 'font-size: 20px;'
            },
            children: [
                {
                    tag: 'li',
                    children: 'a'
                }
            ]
        }
    ]
}
```



##### 通过snabbdom学习vdom

snabbdom：性能强大的虚拟dom库

- 用js模拟dom结构（vnode）
- 新旧vnode对比，得出最小的更新范围，最后更新dom
- 数据驱动视图的模式下，高效控制dom操作 



#### diff算法

- 只比较同一层级，不跨级比较
- tag不相同，则直接删掉重建，不再深度比较
- tag和key，两者都相同，则认为是相同节点，不再深度比较 

从snabbdom源码（snabbdom.ts）看diff算法：

- h函数（生成vnode对象） 
- patch函数
- patchVnode函数
- addVnodes removeVnodes
- updateChildren函数（key的重要性） 



### 模板编译

#### with语法

```js
 const obj = {a: 100, b: 200}
 // 使用with，能改变{}内自由变量的查找方式
 // 将{}内自由变量，当做obj的属性来查找
 with(obj) {
   console.log(a)
   console.log(b)
   console.log(c) // 会报错
 }
```

#### vue-template-complier 将模板编译为render函数 

```shell
npm i vue-template-complier
```

编译成render函数

```js
const compiler = require('vue-template-compiler')

// 插值
const template = `<p>{{message}}</p>`
// 编译出的render函数
with(this){return _c('p',[_v(_s(message))])}
// h -> vnode
// _c -> createElement -> vnode

// 表达式
const template = `<p>{{flag ? message : 'no message found'}}</p>`
with(this){return _c('p',[_v(_s(flag ? message : 'no message found'))])}

// 属性和动态属性
const template = `
    <div id="div1" class="container">
        <img :src="imgUrl"/>
    </div>
`;
with (this) {
    return _c("div", { staticClass: "container", attrs: { id: "div1" } }, [
        _c("img", { attrs: { src: imgUrl } }),
    ]);
}

// 条件
const template = `
    <div>
        <p v-if="flag === 'a'">A</p>
        <p v-else>B</p>
    </div>
`;
with (this) {
    return _c("div", [flag === "a" ? _c("p", [_v("A")]) : _c("p", [_v("B")])]);
}

// 循环
const template = `
    <ul>
        <li v-for="item in list" :key="item.id">{{item.title}}</li>
    </ul>
`;
with (this) {
    return _c(
        "ul",
        _l(list, function (item) {
            return _c("li", { key: item.id }, [_v(_s(item.title))]);
        }),
        0
    );
}

// 事件
const template = `
    <button @click="clickHandler">submit</button>
`;
with (this) {
    return _c("button", { on: { click: clickHandler } }, [_v("submit")]);
}

// v-model
const template = `<input type="text" v-model="name">`;
// 主要看 input 事件
with (this) {
    return _c("input", {
        directives: [
            {
                name: "model",
                rawName: "v-model",
                value: name,
                expression: "name",
            },
        ],
        attrs: { type: "text" },
        domProps: { value: name },
        on: {
            input: function ($event) {
                if ($event.target.composing) return;
                name = $event.target.value;
            },
        },
    });
}


// 编译
const res = compiler.compile(template)
console.log(res.render)
```



```js
// 从 vue 源码中找到缩写函数的含义
function installRenderHelpers (target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}
```



#### 执行render函数生成vnode 

看上面vdom



### 组件渲染过程

- 初次渲染过程

1. 解析模板为render 函数（或在开发环境已完成，vue-loader）
2. 触发响应式，监听data属性 getter setter
3. 执行render函数，生成vnode，patch(elem, vnode)

- 更新过程

1. 修改data，触发setter（此前在getter中已被监听）
2. 重新执行render函数，生成newVnode
3. patch(vnode, newVnode)

- 异步渲染

1. $nextTick
2. 汇总data的修改，一次性更新视图
3. 减少DOM操作次数，提高性能

 

### 前端路由

（具体可看：[vue.js基础/单页面两种路由模式：hash与history](../前端基础汇总/vue.js基础)）

#### hash

hash的特点

- hash变化会触发网页跳转，即浏览器的前进、后退
- hash变化不会刷新页面，SPA必须的特点
- hash永远不会提交到server端（前端自生自灭）



hash 变化，包括：

a. JS 修改 url

b. 手动修改 url 的 hash

c. 浏览器前进、后退



**window.onhashchange**

```js
// 监听hash变化
window.onhashchange = (event) => {
    console.log('old url', event.oldURL)
    console.log('new url', event.newURL)

    console.log('hash:', location.hash)
    // 进行一些操作
}
```



#### h5 history

- 用url规范的路由，但跳转时不刷新页面
- history.pushState、history.replaceState
- window.onpopstate
- 需要后端支持



**history.pushState**方法接受三个参数，依次为：

1、state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。可用它来传一些数据

2、title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。

3、url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。

history.replaceState方法跟pushState一样只不过replaceState是修改当前的状态。



```js
// 页面初次加载，获取 path
document.addEventListener('DOMContentLoaded', () => {
    console.log('load', location.pathname)
})

// 打开一个新的路由
// 【注意】用 pushState 方式，浏览器不会刷新页面
document.getElementById('btn1').addEventListener('click', () => {
    const state = { name: 'page1' }
    console.log('切换路由到', 'page1')
    history.pushState(state, '', 'page1') // 重要！！
})

// 监听浏览器前进、后退
window.onpopstate = (event) => { // 重要！！
    console.log('onpopstate', event.state, location.pathname)
}

// 需要 server 端配合，可参考
// https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90
```



#### 两者选择

- toB的系统推荐用hash，简单易用，对url规范不敏感
- toC的系统，可以考虑选择h5 history，但需要服务端支持 



### 面试真题演练

##### v-show和v-if的区别

- v-show通过css display控制显示和隐藏
- v-if 组件真正的渲染和销毁，而不是显示和隐藏
- 频繁切换显示状态用v-show，否则用v-if

##### 为何v-for中要用key

- 必须用key，且不能是index和random
- diff算法中通过tag和key来判断，是否是sameNode
- 减少渲染次数，提升渲染性能

##### 描述Vue组件生命周期（有父子组件的情况）

- 单组件生命周期图
- 父子组件生命周期关系

##### Vue组件如何通讯（常见）

- 父子组件props和this.$emit
- 自定义组件event.$no event.$off event.$emit
- vuex

##### 描述组件渲染和更新的过程

- render函数
- data  setter和getter
- watcher监听数据setter和getter 
- 触发re-render

##### 双向数据绑定v-model的实现原理

- input元素的value = this.name
- 绑定input事件this.name = $event.target.value
- data更新触发re-render

##### 对MVVM的理解

（具体可看：[vue.js基础/#二、MVVM](../前端基础汇总/vue.js基础)）

##### computed有何特点

- 缓存，data不变不会重新计算
- 提高性能

##### 为何组件data必须是一个函数？

- vue组件相当于class，它可能会被用到很多地方，这就类似于new class实例

- 而对于每一个实例，data都必须是独立的，所以要用函数返回

- 如果不用函数，那多个实例就公用一个data了

##### ajax请求应该放在哪个生命周期

- mounted
- JS是单线程的，ajax异步获取数据
- 放在mounted之前没有用，只会让逻辑更加混乱（event loop 因为生命周期是同步的，ajax是异步的，异步事件是在所有同步执行完成之后执行，放在created，会让人觉得ajax执行在mounted前，即mounted前就已经获得了ajax数据，其实ajax数据是在vue初始化完成后才获取的）

##### 如何将组建所有props传递给子组件

- $props
- `<User v-bind="$props" />`

##### 如何自己实现v-model

看上面vue高级特性 - 自定义组件 v-model

##### 多个组件有相同的逻辑，如何抽离

- mixin（还有缺点）

##### 何时使用异步组件

- 加载大组件
- 路由异步加载

##### 何时使用keep-alive

- 缓存组件，不需要重复渲染
- 如多个静态tab页的切换
- 优化性能

##### 何时需要使用beforeDestory

- 解绑自定义事件event.$off
- 清除定时器
- 解绑自定义的DOM事件，如addEventListener window  scroll等

##### vuex中action和mutation有何区别

- action中处理异步，mutation不可以
- mutation做原子操作
- action可以整合多个mutation

##### vue如何监听数组变化

- Object.defineProperty不能监听数组变化
- 重新定义原型，重写push pop等方法，实现监听
- Proxy可以原生支持监听数组变化

##### diff算法的时间复杂度

- O(n)
- 在O(n^3)基础上做了一些调整

##### 简述diff算法过程

- patch(elem, vnode)和patch(vnode, newVnode)
- patchVnode和addVnodes和removeVnodes
- updateChildren(key的重要性)

##### vue为何是异步渲染，$nextTick何用

- 异步渲染（以及合并data修改），以提高渲染性能
- $nextTick在DOM更新完之后，触发回调

##### vue常见性能优化

- 合理使用v-show和v-if

- 合理使用computed

- v-for避免和v-if同时使用

- 自定义事件、dom时间及时销毁

- 合理使用异步组件

- 合理使用keep-alive

- data层级不要太深

- 使用vue-loader在开发环境做模板编译（预编译）

- webpack层面的优化

- 前端通用的性能优化，如图片懒加载

- 使用SSR

  

## Vue3学习

### Vue3比Vue2有什么优势

- 性能更好
- 体积更小
- 更好的ts支持
- 更好的代码组织
- 更好的逻辑抽离
- 更多新功能

### vue3生命周期

#### Options API生命周期

- boforeDestory改为beforeUnmount

- destoryed改为unmounted

- 其他沿用vue2的生命周期

#### Composition API生命周期

如何看待Composition API和Options API

如何理解ref toRef 和 toRefs

vue3升级了哪些重要的功能

Composition API如何实现代码逻辑复用

vue3如何实现响应式

watch和watchEffect的区别是什么

setup中如何获取组件实例

vue3为何比vue2快

Vite是什么

Composition API和React Hooks的对比



toRef 和 toRefs如何使用

ref toRef 和 toRefs的最佳使用方式

为什么需要用ref





## React使用

### React基本使用

- JSX语法
  - 变量、表达式

    我们可以在JSX中使用JS表达式（不能适用于语句），表达式写在大括号“{}”中

    - `{2+2}`  `{user.firstName}`  `{formatName(user)}`

    - 在JSX中不能使用if-else语句，但可以使用conditional（三元运算）表达式来替代

      ```js
      const show = true;
      {show ? <img src="xxx.png"/> : ''}
      ```

    - 循环

      ```js
      const list = [1, 2, 3, 4, 5];
      {
          list.map((item, index) => {
              return <li key={index}>{item}</li>
          })
      }
      ```

  - class style

    - React推荐使用内联样式。我们可以使用camelCase语法设置内联样式。

      React会在指定元素数字后自动添加px

      ```js
      var myStyle = {
          fontSize: 100,  // css中为font-size
          color: '#FF0000'
      };
      <h1 style={myStyle}>xxx</h1>
      ```

    - ```js
      <h1 style = {{background: red;}}>xxx</h1> //两个大括号
      ```

    - ```js
      .red-btn {
          background: red;
      }
      <h1 className='red-btn'>xxx</h1>  // 使用className而不是class
      ```

  - 原生HTML

    ```js
    var item = `<h1>hello</h1>`
    <li
    	key={index}
    	onClick={this.handleItemDelete.bind(this, index)}
        dangerouslySetInnerHTML={__html: item}
    >
    </li>
    ```

- 子元素和组件

- 条件渲染

  - if else

    ```js
    const whiteBtn = <button className="btn-white">white btn</button>
    const blackBtn = <button className="btn-black">black btn</button>
    
    if (this.state.theme === 'black') {
        return blackBtn
    } else {
        return whiteBtn
    }
    ```

  - 三元表达式

    ```js
    return <div>
        { this.state.theme === 'black' ? blackBtn : whiteBtn }
    </div>
    ```

  - 逻辑运算符 &&  ||

    ```js
    return <div>
        { this.state.theme === 'black' && blackBtn }
    </div>
    ```

- 列表渲染

  - map

    ```js
    class ListDemo extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                list: [
                    {
                        id: 'id1',
                        title: 'title1'
                    },
                    {
                        id: 'id2',
                        title: 'title2'
                    },
                    {
                        id: 'id3',
                        title: 'title3'
                    }
                ]
            }
        }
        render() {
            return <ul>{this.state.list.map((item, index) => {
                return <li key={item.id}>index {index}; title {item.title}</li>
            })}</ul>
        }
    }
    ```

  - key

- 事件

  - bind this

    ```js
    // 将这种作用域的修改放在constructor中，保证作用域绑定操作只执行一次。
    this.handleBtnClick = this.handleBtnClick.bind(this) //绑定this为对应组件<TodoList/>
    
    <button className="button" onClick={this.handleBtnClick}>提交</button>
    
    handleBtnClick() {
        // console.log(this)  // this默认是undefined
        this.setState({
            inputValue: ''
        })
    }
    
    // 用静态方法，this指向当前实力 不需要再绑定this
    handleBtnClick = () => {
        this.setState({
            inputValue: ''
        })
    }
    ```

  - 关于event参数

    ```js
    handleBtnClick = (event) => {
        event.preventDefault()  // 阻止默认行为
        event.stopPropagation() // 阻止冒泡
        console.log('target', event.target)  // 指向当前元素，即当前元素触发
        console.log('current target', event.currentTarget) // 指向当前元素，假象！
        
        // 注意，event其实是React封装的。可以看__proto__constructor是 SyntheticEvent
        conole.log('event', event)
        
        // 原生event如下。其__proto__constructor是 MouseEvent
        console.log('NativeEvent', event.nativeEvent)
        console.log('NativeEvent target', event.nativeEvent.target) //指向当前元素
        console.log('NativeEvent current target', event.nativeEvent.currentTarget)
    	// 指向document元素
    }
    ```

  - 传递自定义参数

    ```js
    <button className="button" onClick={this.handleBtnClick(id, title)}>提交</button>
    
    handleBtnClick(id, title, event) {
        console.log(id, title)
        console.log('event', event)  // 最后追加一个参数，即可接收event
    }
    ```

- 表单

  - 受控组件
  - input textarea select 用value
  - checkbox radio 用checked

- 组件和props（类型检查）

  - props传递数据
  - props传递函数
  - props类型检查

- state和setState（重点）

  - 不可变值
  - 可能是异步更新
  - 可能会被合并

- 组件生命周期