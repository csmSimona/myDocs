

# 前端框架及项目面试

## 面试题

### Vue面试题

- v-show和v-if的区别
- 为何v-for中要用key
- 描述Vue组件生命周期（有父子组件的情况）
- Vue组件如何通讯
- 描述组件渲染和更新的过程
- 双向数据绑定v-model的实现原理

### react面试题

- react组件如何通讯

- JSX本质是什么

- context是什么，有何用途

- shouldComponentUpdate的用途

- 描述redux单向数据流

- setState是同步还是异步（场景见下图） ： 0 0 2 3  前两步合并

  ![](..\picture\setState异步.png)

### 框架综合应用

- 基于react设计一个todolist（组件结构，redux state数据结构）
- 基于Vue设计一个购物车（组件结构，Vuex state数据结构）

### webpack面试题

- 前端代码为何要进行构建和打包
- module chunk bundle 分别是什么意思，有何区别
- loader和plugin的区别
- webpack如何实现懒加载
- webpack常见性能优化
- babel-runtime和babel-polyfill的区别

## Vue使用

### Vue基本使用

- 插值表达式

- 指令、动态属性

- v-html：会有XSS风险，会覆盖子组件（可以使用`<pre>`标签）

- computed和watch

  - computed有缓存，data不变则不会重新计算

  - watch如何深度监听？

    ```js
    watch: {
        // 普通监听
        name(oldVal, val){
            console.log(oldVal)
        },
        firstName: {
            handler(newName, oldName) {
                this.fullName = newName + ' ' + this.lastName;
            },
            // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法
            immediate: true,  	// 是否最初绑定的时候就执行
            deep: true 			// 是否深度监听
        }
    }
    ```

    `deep`的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改`obj`里面任何一个属性都会触发这个监听器里的 handler。

    优化，我们可以是使用字符串形式监听。

    ```js
    watch: {
      'obj.a': {
        handler(newName, oldName) {
          console.log('obj.a changed');
        },
        immediate: true,
        // deep: true
      }
    }
    ```

  - watch监听引用类型，拿不到oldVal

- class和style

  - 使用动态属性
  - 使用驼峰式写法

- 条件渲染

  - v-if v-else 的用法，可使用变量，也可以使用 === 表达式
  - v-if 和 v-show 的区别？
  - v-if 和 v-show 的使用场景？数据改变频繁用 v-show

- 列表渲染

  - 如何遍历对象？也可以用v-for

  - key的重要性，key不能乱写（如random或者index）

  - v-for 和 v-if 不能一起使用

    v-for比v-if的优先级更高，这就说明在v-for的每次循环运行中每一次都会调用v-if的判断，所以不推荐v-if和v-for在同一个标签内同时使用。
    
    解决方法：过滤一个列表中的项目 (比如 v-for=“user in users” v-if=“user.isActive”)。在这种情形下，请将 users替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表

- 事件

  - event参数，自定义参数

    1.event是原生的event对象，没有经过任何的装饰

    2.事件被挂载到当前元素

  - 事件修饰符

    ```vue
    <!-- 阻止单击事件继续传播 -->
    <a v-on:click.stop="doThis"></a>
    <!-- 提交事件不再重载页面 -->
    <form v-on:submit.prevent="onSubmit"></form>
    <!-- 修饰符可以串联 -->
    <a v-on:click.stop.prevent="doThat"></a>
    <!-- 只有修饰符 -->
    <form v-on:submit.prevent></form>
    <!-- 添加事件监听器时使用事件捕获模式 -->
    <!-- 事件捕获：事件从最不精确的对象(document对象)开始触发，然后到最精确 -->
    <div v-on:click.capture="doThis">...</div>
    <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
    <!-- 即事件不是从内部元素触发的 -->
    <div v-on:click.self="doThat">...</div>
    ```

  - 按键修饰符

    ```vue
    <!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
    <button @click.ctrl="onClick">A</button>
    <!-- 有且只有 Ctrl 被按下的时候才触发 -->
    <button @click.ctrl.exact="onCtrlClick">A</button>
    <!-- 没有任何系统修饰符被按下的时候才触发 -->
    <button @click.exact="onCtrlClick">A</button>
    ```

  - 【观察】事件 被绑定到哪里？

- 表单

  - v-model

    `<textarea v-model="desc"></textarea>`

    注意：`<textarea>{{desc}}</textarea>`是不允许的

  - 常见的表单项 textarea checkbox radio select

  - 修饰符 lazy number trim （v-model.lazy、v-model.number、v-model.trim）
  
    - 在输入框中，v-model 默认是同步数据，使用 **.lazy** 会转变为在 change 事件中同步 ， 也就是在**失去焦点 或者 按下回车键时才更新**
    - **.number 修饰符可以将 输入的值转化为Number类型** ，否则虽然你输入的是数字 但它的类型其实是String，在数字输入框中比较有用
    - **.trim** 修饰符会自动过滤掉输入的**首尾空格**

### Vue组件使用

- props 和 $emit（父子组件之间的通讯）

  ```js
  props: {
      list: {
          type: Array,
          default() {
              return []
          }
      }
  }
  ```
  ```js
  this.$emit(事件方法, 值)
  ```

- 组件间通讯 - 自定义事件（组件之间没有关系或者层级比较深）

  ```js
  import event from './event.js'
  event.$emit(事件方法, 值)
  ```
  ```js
  // 及时解绑自定义事件
  beforeDestory() {
      // 及时销毁，否则可能造成内存泄漏
      event.$off('onAddTitle', this.addTitleHandler)
  }
  ```

  event.js

  ```js
  import Vue from 'vue'
  
  export default new Vue()
  ```

  

- 组件生命周期

  - 单个组件

    created  页面还没开始渲染，但Vue实例已经初始化完成

    mounted  页面渲染完成  基本情况在mounted中进行操作，如ajax获取信息，绑定事件等

    beforeDestroy  解除绑定，销毁子组件以及事件监听器，如自定义事件，setTimeout，window、document事件

  - 父子组件

    父组件先开始初始化，再子组件初始化，子组件渲染完成后，父组件才渲染完成

    index created

    list created

    list mounted

    index mounted

    父组件先开始进入更新状态，再子组件，子组件更新完成后，父组件才更新完成

    index beforeUpdate

    list beforeUpdate

    list updated

    index updated

    销毁destroy同理

### Vue高级特性

- 自定义组件 v-model（如颜色选择）

  index.vue

  ```vue
  <template>
      <p>{{name}}</p>
      <CustomVModel v-model="name" />
  </templete>
  <script>
  import CustomVModel from './CustomVModel'
  export default{
  	components: {
      	CustomVModel
  	},
      data() {
          return() {
              name: 'csm'
          }
      }
  }
  </script>
  ```

  CustomVModel.Vue

  ```vue
  <template>
      <!--	
          注意：
          1.input使用:value而不是v-model
          2.change和model.event要对应起来
          3.content属性对应起来（model里面定义的prop对应props里面的属性）
      -->
      <input type="text" :value="content" @input="$emit('change', $event.target.value)">
  </templete>
  <script>
  export default{
  	model: {
      	prop: 'content',
          event: 'change'
  	},
      props:{
          content: String,
          default() {
              return ''
          }
      }
  }
  </script>
  ```

- $nextTick，ref

  - Vue是异步渲染
  - data改变之后，DOM不会立刻渲染
  - $nextTick会在DOM渲染之后被触发，以获取最新DOM节点

  ```vue
  <template>
  	<div>
          <ul ref="ul1">
              <li v-for="(item, index) in list" :key="index">{{item}}</li>
          </ul>
          <button @click="addItem">
              添加一项
          </button>
      </div>
  </template>
  <script>
      data() {
          return {
              list: ['a', 'b', 'c']
          }
      },
          methods: {
              addItem() {
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  // 1.异步渲染，$nextTick待DOM渲染完后再回调
                  // 2.页面渲染时会将data的修改做整合，多次data修改只会渲染一次
                  this.$nextTick(() => {
                      const ulElem = this.$refs.ul1
                      console.log(ulElem.childNodes.length)   
                      // 点击后 6，如果没有$nextTick是3
                  })
              }
          }
  </script>
  ```

- slot

  没有插槽的情况下在组件标签内写一些内容是不起任何作用的，当在组件中声明了slot元素后，在组件元素内写的内容就会替换slot。

  用于父组件中往子组件中插入一段内容。

  - 基本使用

    index.vue

    ```vue
    <template>
    	<SlotDemo :url="website.url">
        	{{website.title}}
        </SlotDemo>
    </template>
    <script>
    import SlotDemo from './SlotDemo'
    export default {
        components: {
            SlotDemo
        },
        data() {
            return {
                website: {
                    url: 'http://imooc.com/',
                    title: 'imooc',
                    subTitle: '程序员的梦工厂'
                }
            }
        }
    }
    </script>
    ```

    SlotDemo.vue

    ```vue
    <template>
    	<a :href="url">
            <slot>
                默认内容，即父组件没设置内容时，这里显示
            </slot>
        </a>
    </template>
    ```

  - 作用域插槽

    作用域插槽的主要作用是在书写插槽内容时可以获取到插槽作用域的值 

    index.Vue

    ```vue
    <template>
    	<ScopedSlotDemo :url="website.url">
        	<template v-slot="slotProps">
                <!-- slotProps.slotData 等于 子组件中的website -->
    			{{slotProps.slotData.title}}
    		</template>
        </ScopedSlotDemo>
    </template>
    <script>
    import ScopedSlotDemo from './ScopedSlotDemo'
    export default {
        components: {
            ScopedSlotDemo
        },
        data() {
            return {
                website: {
                    url: 'http://imooc.com/',
                    title: 'imooc',
                    subTitle: '程序员的梦工厂'
                }
            }
        }
    }
    </script>
    ```

    ScopedSlotDemo

    ```vue
    <template>
        <a :href="url">
            <slot :slotData="website">
                {{website.subTitle}} <!-- 默认值显示 subTitle ，即父组件不传内容时 -->
            </slot>
        </a>
    </template>
    
    <script>
    export default {
        props: ['url'],
        data() {
            return {
                website: {
                    url: 'http://wangEditor.com/',
                    title: 'wangEditor',
                    subTitle: '轻量级富文本编辑器'
                }
            }
        }
    }
    </script>
    ```

  - 具名插槽

    index.Vue

    ```vue
    <template>
    	<NamedSlot>
            <!-- 缩写 <template #header> -->
            <template v-slot:header>
            	<h1>将插入header slot中</h1>
            </template>
    		<p>将插入到main slot中，即未命名的slot</p>
    		<template v-slot:footer>
            	<h1>将插入footer slot中</h1>
            </template>
        </NamedSlot>
    </template>
    ```

    NamedSlot.Vue

    ```vue
    <template>
    	<div>
            <header>
            	<slot name="header"></slot>
            </header>
            <main>
            	<slot></slot>
            </main>
            <footer>
            	<slot name="footer"></slot>
            </footer>
        </div>
    </template>
    ```

- 动态组件

  - 用法 `<component :is="component-name" />`  传组件名
  - 需要根据数据，动态渲染的场景，如常见的有文本，视频，图片组件的新闻详情页。即组件类型不确定。
  - 每次都会销毁和重建，为了性能优化，也可以使用keep-alive缓存

- 异步组件

  - import()函数

    同步引入组件：`import formDemo from './formDemo'`

    异步引入组件：

    ```vue
    components:{
    	formDemo: () => import('./formDemo')
    }
    ```

  - 按需加载，异步加载大组件

- keep-alive

  ```vue
  <keep-alive>
  	<KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
  </keep-alive>
  ```

  - 缓存组件

  - 频繁切换，不需要重复渲染，用于tab切换等

  - Vue常见性能优化

  - v-show和keep-alive的区别：

    v-show是在css层面，控制元素的显示方式，将display属性在block和none来回切换；

    keep-alive是vue中的一个抽象组件，用于保存组件的渲染状态。

  ```vue
  <keep-alive :include="whiteList" :exclude="blackList" :max="amount">
      <router-view></router-view>
  </keep-alive>
  ```

  **include**定义缓存白名单，keep-alive会缓存命中的组件；**exclude**定义缓存黑名单，被命中的组件将不会被缓存；**max**定义缓存组件上限，超出上限使用LRU的策略置换缓存数据。

  > [内存管理](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F5633616)的一种页面置换算法，对于在内存中但又不用的[数据块](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%95%B0%E6%8D%AE%E5%9D%97%2F107672)（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。

- mixin

  mixin.js

  ```js
  export default {
      data() {
          return {
              city: ''
          }
      },
      methods: {
          showName() {
              console.log(this.name)
          }
      }
  }
  ```

  index.Vue

  ```vue
  <script>
  import myMixin from './mixin'
  export default {
      mixins: [myMixin], // 可以添加多个，会自动合并起来
      data() {
          return {
              name: ''
          }
      },
      methods: {
      }
  }
  </script>
  ```

  - 多个组件有相同逻辑，抽离出来
  - mixin并不是完美的解决方案，会有一些问题
    - 变量来源不明确，不利于阅读
    - 多mixin可能造成命名冲突
    - mixin和组件可能出现多对多的关系，复杂度较高
  - Vue3提出的Composition API旨在解决这些问题

### Vuex使用

- 用于Vue组件

  - dispatch
  - commit
  - mapState
  - mapGetters
  - mapActions
  - mapMutations

- actions中才能做异步操作，不能在mutations中做

  ![vux过程](..\picture\vux过程.png)

### Vue-router使用

- 路由模式（hash，H5 history）

  - hash模式（默认），如 http://abc.com/#/user/10
  - H5 history模式，如 http://abc.com/user/20
  - 后者需要server端支持，因此无特殊需求可选择前者

- 路由配置（动态路由，懒加载）

  - 动态路由

    ```js
    const User = {
        template: '<div>User {{ $route.params.id }}</div>'
    }
    
    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头 能命中'/user/20','/user/10'等格式的路由
            { path: '/user/:id', components: User }
        ]
    })
    ```

  - 懒加载

    ```js
    const router = new VueRouter({
        routes: [
            { 
                path: '/user/:id', 
                // 异步加载组件
                components: () => import('./../components/Navigator')
            }
        ]
    })
    ```

    

## Vue原理

### 组件化基础

- “很久以前”就有组件化
- 数据驱动视图（MVVM，setState）

### 响应式

- 组件data的数据一旦变化，立刻触发视图更新

- 核心API - Object.defineProperty

  - 基本用法

    `Object.defineProperty(obj, props, descriptor)`
  
    作用： 在对象上定义一个新属性或者修改原有属性
  
    返回值： 修改后的目标对象obj
  
    参数定义：
  
    - obj: 在其上定义或修改属性的目标对象
  
  
    - props: 属性名称
  

    - descriptor: 属性描述符
  
  
    ```js
    const data = {}
    const name = 'zhangsan'
    Object.defineProperty(data, "name", {
        get: function() {
            console.log('get')
            return name
        },
        set: function() {
            console.log('set')
            name = newVal
        }
    })
    
    // 测试
  console.log(data.name) // get zhangsan
    data.name = 'lisi'     // set
    ```
  
  - 如何深度监听data变化（简单实现）
  
    ```js
    function updateView() {
        console.log('视图更新')
    }
    function defineReactive(target, key, value) {
        // 深度监听
        observe(value)
        // 核心API
        Object.defineProperty(target, key, {
            get() {
                return value
            },
            set(newValue) {
                if (newValue !== value) {
                    // 设置新值
                    observe(newValue)
                    value = newValue
                    // 触发更新视图
                    updateView()
                }
            }
        })
    }
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            // 不是对象或数组
            return target
        }
        // 重新定义各个熟悉（for in也可以遍历数组）
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    
    const data = {
        name: 'zhangsan',
        age: 20,
        info: {
            address: 'beijing' // 需要深度监听
        }
    }
    
    data.info.address = 'shanghai'
    ```
  
  - 如何监听数组变化
  
    ```js
    // 重新定义数组原型
    
    const oldArrayProperty = Array.propertype;
    // 创建新对象，原型指向oldArrayProperty，再扩展新的方法不会影响原型
    const arrProto = Object.create(oldArrayProperty);
    
    // 比如 这个新对象有push方法，则先实现他自己定义的push方法
    // 然后再处理原型数组的push方法  
    // 即 Array.prototype.push(this, ...arguments)
    ['push', 'pop', 'shift', 'splice'].forEach(methodName => {
        arrProto[methodName] = function () {
            updateView() //触发视图更新
            // 再去实现原型数组中对应的方法
            oldArrayProperty[methodName].call(this, ...arguments)
        }
    })
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            return target
        }
        // 监听数组
        if (Array.isArray(target)) {
            target.__proto__ = arrProto
        }
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    ```
  
  - 一些缺点（Vue3.0启用Proxy）
  
    - 深度监听需要递归到底，一次性计算量大
    - 无法监听新增/删除属性（因此出现 Vue.set Vue.delete 来弥补该缺点）
    - 无法原生监听数组，需要特殊处理
  
  - Proxy有兼容性问题，且无法polyfill

### vdom（虚拟dom）和diff

（[react基础](../前端基础汇总/react基础)中有写react相关虚拟dom和diff算法）

- vdom是实现vue和React的重要基石
- diff算法是vdom中最核心、最关键的部分

#### vdom

用JS模拟DOM结构，计算出更小的变更，操作DOM（具体可以看 react基础 中  虚拟DOM  这一节）

##### 用js模拟DOM结构

```html
<!-- DOM结构 -->
<div id="div1" class="container">
    <p>
        vdom
    </p>
    <ul style="font-size: 20px;">
        <li>a</li>
    </ul>
</div>
```

```js
// js模拟
{
    tag: 'div',
    props: {
        className: 'container',
        id: 'div1'
    },
    children: [
        {
            tag: 'p',
            children: 'vdom'
        }, {
            tag: 'ul',
            props: {
                style: 'font-size: 20px;'
            },
            children: [
                {
                    tag: 'li',
                    children: 'a'
                }
            ]
        }
    ]
}
```



##### 通过snabbdom学习vdom

snabbdom：性能强大的虚拟dom库

- 用js模拟dom结构（vnode）
- 新旧vnode对比，得出最小的更新范围，最后更新dom
- 数据驱动视图的模式下，高效控制dom操作 



#### diff算法

- 只比较同一层级，不跨级比较
- tag不相同，则直接删掉重建，不再深度比较
- tag和key，两者都相同，则认为是相同节点，不再深度比较 

从snabbdom源码（snabbdom.ts）看diff算法：

- h函数（生成vnode对象） 
- patch函数
- patchVnode函数
- addVnodes removeVnodes
- updateChildren函数（key的重要性） 



### 模板编译

#### with语法

```js
 const obj = {a: 100, b: 200}
 // 使用with，能改变{}内自由变量的查找方式
 // 将{}内自由变量，当做obj的属性来查找
 with(obj) {
   console.log(a)
   console.log(b)
   console.log(c) // 会报错
 }
```

#### vue-template-complier 将模板编译为render函数 

```shell
npm i vue-template-complier
```

编译成render函数

```js
const compiler = require('vue-template-compiler')

// 插值
const template = `<p>{{message}}</p>`
// 编译出的render函数
with(this){return _c('p',[_v(_s(message))])}
// h -> vnode
// _c -> createElement -> vnode

// 表达式
const template = `<p>{{flag ? message : 'no message found'}}</p>`
with(this){return _c('p',[_v(_s(flag ? message : 'no message found'))])}

// 属性和动态属性
const template = `
    <div id="div1" class="container">
        <img :src="imgUrl"/>
    </div>
`;
with (this) {
    return _c("div", { staticClass: "container", attrs: { id: "div1" } }, [
        _c("img", { attrs: { src: imgUrl } }),
    ]);
}

// 条件
const template = `
    <div>
        <p v-if="flag === 'a'">A</p>
        <p v-else>B</p>
    </div>
`;
with (this) {
    return _c("div", [flag === "a" ? _c("p", [_v("A")]) : _c("p", [_v("B")])]);
}

// 循环
const template = `
    <ul>
        <li v-for="item in list" :key="item.id">{{item.title}}</li>
    </ul>
`;
with (this) {
    return _c(
        "ul",
        _l(list, function (item) {
            return _c("li", { key: item.id }, [_v(_s(item.title))]);
        }),
        0
    );
}

// 事件
const template = `
    <button @click="clickHandler">submit</button>
`;
with (this) {
    return _c("button", { on: { click: clickHandler } }, [_v("submit")]);
}

// v-model
const template = `<input type="text" v-model="name">`;
// 主要看 input 事件
with (this) {
    return _c("input", {
        directives: [
            {
                name: "model",
                rawName: "v-model",
                value: name,
                expression: "name",
            },
        ],
        attrs: { type: "text" },
        domProps: { value: name },
        on: {
            input: function ($event) {
                if ($event.target.composing) return;
                name = $event.target.value;
            },
        },
    });
}


// 编译
const res = compiler.compile(template)
console.log(res.render)
```



```js
// 从 vue 源码中找到缩写函数的含义
function installRenderHelpers (target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}
```



#### 执行render函数生成vnode 

看上面vdom



### 组件渲染过程

- 初次渲染过程

1. 解析模板为render 函数（或在开发环境已完成，vue-loader）
2. 触发响应式，监听data属性 getter setter
3. 执行render函数，生成vnode，patch(elem, vnode)

- 更新过程

1. 修改data，触发setter（此前在getter中已被监听）
2. 重新执行render函数，生成newVnode
3. patch(vnode, newVnode)

- 异步渲染

1. $nextTick
2. 汇总data的修改，一次性更新视图
3. 减少DOM操作次数，提高性能

 

### 前端路由

（具体可看：[vue.js基础/单页面两种路由模式：hash与history](../前端基础汇总/vue.js基础)）

#### hash

hash的特点

- hash变化会触发网页跳转，即浏览器的前进、后退
- hash变化不会刷新页面，SPA必须的特点
- hash永远不会提交到server端（前端自生自灭）



hash 变化，包括：

a. JS 修改 url

b. 手动修改 url 的 hash

c. 浏览器前进、后退



**window.onhashchange**

```js
// 监听hash变化
window.onhashchange = (event) => {
    console.log('old url', event.oldURL)
    console.log('new url', event.newURL)

    console.log('hash:', location.hash)
    // 进行一些操作
}
```



#### h5 history

- 用url规范的路由，但跳转时不刷新页面
- history.pushState、history.replaceState
- window.onpopstate
- 需要后端支持



**history.pushState**方法接受三个参数，依次为：

1、state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。可用它来传一些数据

2、title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。

3、url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。

history.replaceState方法跟pushState一样只不过replaceState是修改当前的状态。



```js
// 页面初次加载，获取 path
document.addEventListener('DOMContentLoaded', () => {
    console.log('load', location.pathname)
})

// 打开一个新的路由
// 【注意】用 pushState 方式，浏览器不会刷新页面
document.getElementById('btn1').addEventListener('click', () => {
    const state = { name: 'page1' }
    console.log('切换路由到', 'page1')
    history.pushState(state, '', 'page1') // 重要！！
})

// 监听浏览器前进、后退
window.onpopstate = (event) => { // 重要！！
    console.log('onpopstate', event.state, location.pathname)
}

// 需要 server 端配合，可参考
// https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90
```



#### 两者选择

- toB的系统推荐用hash，简单易用，对url规范不敏感
- toC的系统，可以考虑选择h5 history，但需要服务端支持 



### 面试真题演练

##### v-show和v-if的区别

- v-show通过css display控制显示和隐藏
- v-if 组件真正的渲染和销毁，而不是显示和隐藏
- 频繁切换显示状态用v-show，否则用v-if

##### 为何v-for中要用key

- 必须用key，且不能是index和random
- diff算法中通过tag和key来判断，是否是sameNode
- 减少渲染次数，提升渲染性能

##### 描述Vue组件生命周期（有父子组件的情况）

- 单组件生命周期图
- 父子组件生命周期关系

##### Vue组件如何通讯（常见）

- 父子组件props和this.$emit
- 自定义组件event.$no event.$off event.$emit
- vuex

##### 描述组件渲染和更新的过程

- render函数
- data  setter和getter
- watcher监听数据setter和getter 
- 触发re-render

##### 双向数据绑定v-model的实现原理

- input元素的value = this.name
- 绑定input事件this.name = $event.target.value
- data更新触发re-render

##### 对MVVM的理解

（具体可看：[vue.js基础/#二、MVVM](../前端基础汇总/vue.js基础)）

##### computed有何特点

- 缓存，data不变不会重新计算
- 提高性能

##### 为何组件data必须是一个函数？

- vue组件相当于class，它可能会被用到很多地方，这就类似于new class实例

- 而对于每一个实例，data都必须是独立的，所以要用函数返回

- 如果不用函数，那多个实例就公用一个data了

##### ajax请求应该放在哪个生命周期

- mounted
- JS是单线程的，ajax异步获取数据
- 放在mounted之前没有用，只会让逻辑更加混乱（event loop 因为生命周期是同步的，ajax是异步的，异步事件是在所有同步执行完成之后执行，放在created，会让人觉得ajax执行在mounted前，即mounted前就已经获得了ajax数据，其实ajax数据是在vue初始化完成后才获取的）

##### 如何将组建所有props传递给子组件

- $props
- `<User v-bind="$props" />`

##### 如何自己实现v-model

看上面vue高级特性 - 自定义组件 v-model

##### 多个组件有相同的逻辑，如何抽离

- mixin（还有缺点）

##### 何时使用异步组件

- 加载大组件
- 路由异步加载

##### 何时使用keep-alive

- 缓存组件，不需要重复渲染
- 如多个静态tab页的切换
- 优化性能

##### 何时需要使用beforeDestory

- 解绑自定义事件event.$off
- 清除定时器
- 解绑自定义的DOM事件，如addEventListener window  scroll等

##### vuex中action和mutation有何区别

- action中处理异步，mutation不可以
- mutation做原子操作
- action可以整合多个mutation

##### vue如何监听数组变化

- Object.defineProperty不能监听数组变化
- 重新定义原型，重写push pop等方法，实现监听
- Proxy可以原生支持监听数组变化

##### diff算法的时间复杂度

- O(n)
- 在O(n^3)基础上做了一些调整

##### 简述diff算法过程

- patch(elem, vnode)和patch(vnode, newVnode)
- patchVnode和addVnodes和removeVnodes
- updateChildren(key的重要性)

##### vue为何是异步渲染，$nextTick何用

- 异步渲染（以及合并data修改），以提高渲染性能
- $nextTick在DOM更新完之后，触发回调

##### vue常见性能优化

- 合理使用v-show和v-if

- 合理使用computed

- v-for避免和v-if同时使用

- 自定义事件、dom时间及时销毁

- 合理使用异步组件

- 合理使用keep-alive

- data层级不要太深

- 使用vue-loader在开发环境做模板编译（预编译）

- webpack层面的优化

- 前端通用的性能优化，如图片懒加载

- 使用SSR

  

## Vue3学习

### vue2.x 有哪些不足

- vue2.x对数组对象的深层监听无法实现。因为组件每次渲染都是将data里的数据通过defineProperty进行响应式或者双向绑定上，之前没有后加的属性是不会被绑定上，也就不会触发更新渲染。
- vue2.x在模板编译过程中会涉及到许多不必要的CPU工作。
- 随着功能的增长，复杂组件的代码变得难以维护。
- vue2.x是采用Facebook的Flow做类型检查，但在某些情况下推断有问题，且对typescript支持不太友好（需要使用一堆装饰器语法）。

### Vue3比Vue2有什么优势

- 性能更好
- 体积更小
- 更好的ts支持
- 更好的代码组织
- 更好的逻辑抽离
- 更多新功能

#### 源码优化

- 更好的代码管理方式：monorepo 根据功能将不同的模块拆分到packages目录下不同的子目录中。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。
- 采用typescript开发，也省去了单独维护d.ts文件的麻烦。

#### 性能优化

- 源码体积优化：移除了一些冷门的feature（比如filter、inline-template等），引入tree-shaking技术减少打包体积。
- 数据劫持优化：使用Proxy代替vue2.x中的defineProperty，能够深层监听数组对象的变化。
- 编译优化：检测出模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。
- 语法API优化：推出composition API优化逻辑组合和优化逻辑复用。



### Vue3生命周期

#### Options API生命周期

- boforeDestory改为beforeUnmount

- destoryed改为unmounted

- 其他沿用vue2的生命周期

#### Composition API生命周期

| Options API     | setup内部的钩子   |
| --------------- | ----------------- |
| beforeCreate    | 不需要            |
| created         | 不需要            |
| beforeMount     | onBeforeMount     |
| mounted         | onMounted         |
| beforeUpdate    | onBeforeUpdate    |
| updated         | onUpdated         |
| beforeUnmount   | onBeforeUnmount   |
| unmounted       | onUnmounted       |
| errorCaptured   | onErrorCaptured   |
| renderTracked   | onRenderTracked   |
| renderTriggered | onRenderTriggered |

```js
import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue'

export default {
    // 等于 beforeCreate 和 created
    setup() {
        console.log('setup')

        onBeforeMount(() => {
            console.log('onBeforeMount')
        })
        onMounted(() => {
            console.log('onMounted')
        })
        onBeforeUpdate(() => {
            console.log('onBeforeUpdate')
        })
        onUpdated(() => {
            console.log('onUpdated')
        })
        onBeforeUnmount(() => {
            console.log('onBeforeUnmount')
        })
        onUnmounted(() => {
            console.log('onUnmounted')
        })
    }
}
```



#### 如何选择

- 不建议共用，会引起混乱
- 小型项目、业务逻辑简单，用Options API
- 中大型项目、业务逻辑复杂，用Composition API



### 如何理解ref toRef 和 toRefs

#### ref

如果想要使用vue3 CompositionAPI的方式写程序，就必须用reactive和ref 创建响应式对象

因为CompositionAPI的方式不支持vue2 的data

- 生成值类型的响应式数据

- 可用于模板和reactive

  **reactive**：接受一个普通对象，返回该普通对象的响应式代理。等同于Vue2.x里面的Vue.observable()

- 通过.value修改值

```vue
<template>
    <p>ref demo {{ageRef}} {{state.name}}</p>
</template>

<script>
import { ref, reactive } from 'vue'

export default {
    name: 'Ref',
    setup() {
        const ageRef = ref(20) // 值类型 响应式 
        const nameRef = ref('双越')

        const state = reactive({
            name: nameRef
        })

        setTimeout(() => {
            console.log('ageRef', ageRef.value)

            ageRef.value = 25 // .value 修改值
            nameRef.value = '双越A'
        }, 1500);

        return {
            ageRef,
            state
        }
    }
}
</script>
```

可以获取DOM元素

```vue
<template>
    <p ref="elemRef">我是一行文字</p>
</template>

<script>
import { ref, onMounted } from 'vue'

export default {
    name: 'RefTemplate',
    setup() {
        const elemRef = ref(null)

        onMounted(() => {
            console.log('ref template', elemRef.value.innerHTML, elemRef.value)
        })

        return {
            elemRef
        }
    }
}
</script>
```



#### toRef

针对一个响应式对象（reactive封装）的prop，创建一个ref

具有响应式，两者保持引用关系

```vue
<template>
    <p>toRef demo - {{ageRef}} - {{state.name}} {{state.age}}</p>
</template>

<script>
import { ref, toRef, reactive } from 'vue'

export default {
    name: 'ToRef',
    setup() {
        const state = reactive({
            age: 20,
            name: '双越'
        })

        const age1 = computed(() => {
            return state.age + 1
        })

        // // toRef 如果用于普通对象（非响应式对象），产出的结果不具备响应式
        // const state = {
        //     age: 20,
        //     name: '双越'
        // }

        const ageRef = toRef(state, 'age')

        // 验证引用关系
        setTimeout(() => {
            state.age = 25
        }, 1500)

        setTimeout(() => {
            ageRef.value = 30 // .value 修改值
        }, 3000)

        return {
            state,
            ageRef
        }
    }
}
</script>
```



#### toRefs

- 将响应式对象（reactive封装）转化为普通对象
- 对象的每个prop都是对应的ref
- 两者保持引用关系



```vue
<template>
    <p>toRefs demo {{age}} {{name}}</p>
</template>

<script>
import { ref, toRef, toRefs, reactive } from 'vue'

export default {
    name: 'ToRefs',
    setup() {
        const state = reactive({
            age: 20,
            name: '双越'
        })

        const stateAsRefs = toRefs(state) // 将响应式对象，变成普通对象

        // const { age: ageRef, name: nameRef } = stateAsRefs // 每个属性，都是 ref 对象
        // return {
        //     ageRef,
        //     nameRef
        // }

        // 验证引用关系
        setTimeout(() => {
            state.age = 25
        }, 1500)

        return stateAsRefs
        
        // 如果直接解构会丢失响应式数据（就是没有双向数据绑定了）
        // return {
        //     ...state
        // }
    }
}
</script>
```



##### 应用

**合成函数返回响应式对象**

```js
function useFeatureX() {
    const state = reactive({
        x: 1,
        y: 2
    })
    // 逻辑运行状态，省略N行
    // 返回时转换为ref
    return toRefs(state)
}
```

```js
export default {
    setup() {
        // 可以在不失去响应性的情况下破坏结构
        const { x, y } = useFeatureX()
        return {
            x, y
        }
    }
}
```



#### 最佳使用方式

- 用reactive做对象的响应式，用ref做值类型的响应式
- setup中返回toRefs(state)，或者toRef(state, 'xxx')
- ref的变量命名都用xxxRef
- 合成函数返回响应式对象时，使用toRefs



#### 为什么存在

##### 为什么需要ref

- 返回值类型，会丢失响应式
- 如在setup、computed、合成函数，都有可能返回值类型

##### 为什么需要.value

- ref是一个对象（不丢失响应式），value存储值
- 通过.value属性的get和set实现响应式
- 用于模板、reactive时，不需要.value，其他情况都需要

##### 为什么需要toRef和toRefs

- 初衷：不丢失响应式的情况下，把对象数据 分解/扩散
- 前提：针对的是响应式对象（reactive封装的）非普通对象
- 注意：不创造响应式，而是延续响应式



### vue3升级了哪些重要的功能

#### createApp

```js
// vue2.x
const app = new Vue({ /* 选项 */})

Vue.use(/* ... */)
Vue.mixin(/* ... */)
Vue.component(/* ... */)
Vue.directive(/* ... */)

// vue3.x
const app = Vue.createApp({ /* 选项 */})

app.use(/* ... */)
app.mixin(/* ... */)
app.component(/* ... */)
app.directive(/* ... */)
```

#### emits属性

父组件

```vue
<HelloWorld :msg="msg" @onSayHello="sayHello"
```

子组件

````vue
export default {
    name: 'HelloWorld',
    props: {
    	msg: String
    },
	emits: ['onSayHello'],
    setup(props, { emit }) {
    	emit('onSayHello', 'aaa')
    }
}
````

#### 生命周期

看上面

#### 多事件

```vue
<!-- 在methods里定义one two两个函数-->
<button @click="one($event), two($event)">
    Submit
</button>
```

#### Fragment

模板中不需要再加一个div

```vue
<!-- vue2.x 组件模板 -->
<template>
	<div>
        <h3>{{title}}</h3>
        <div v-html="content"></div>
    </div>
</template>

<!-- vue3 组件模板 -->
<template>
    <h3>{{title}}</h3>
    <div v-html="content"></div>
</template>
```

#### 移除.sync

改成v-model:xx形式，都是语法糖

#### 异步组件的写法

```vue
<!-- vue2 写法 -->
new Vue({
    // ...
    components: {
    	'my-component': () => import('./my-component.vue')
    }
})
<!-- vue3 写法 -->
import { createApp, defineAsyncComponent } from 'vue'
createApp({
	// ...
    components: {
    	AsyncComponent: defineAsyncComponent(() => import('./my-component.vue'))
    }
})
```

#### 移除filter

#### Teleport

`to="body"` 加到body里面

```vue
<button @click="modalOpen = true">
    Open full screen modal! (with teleport)
</button>
<teleport to="body">
	<div v-if="modalOpen">
        <div>
            <button @click="modalOpen = false">
                Close
            </button>
        </div>
    </div>
</teleport>
```

#### Suspense

```vue
<Suspense>
	<template>
    	<Test1/> <!-- 是一个异步组件 -->
    </template>
    <!-- #fallback 就是一个具名插槽
		即Suspense组件内部，有两个slot，
		其中一个局名为fallback-->
    <template #fallback>
    	loading
    </template>
</Suspense>
```

#### Composition API

看上面



### Composition API如何实现代码逻辑复用

- 抽离逻辑代码到一个函数
- 函数命名约定为useXxxx格式（React Hooks也是）
- 在setup中引用useXxxx函数

**代码演示：MousePosition**

useMousePosition.js

```js
import { ref, onMounted, onUnmounted } from 'vue'

function useMousePosition() {
    const x = ref(0)
    const y = ref(0)

    function update(e) {
        x.value = e.pageX
        y.value = e.pageY
    }

    onMounted(() => {
        console.log('useMousePosition mounted')
        window.addEventListener('mousemove', update)
    })

    onUnmounted(() => {
        console.log('useMousePosition unMounted')
        window.removeEventListener('mousemove', update)
    })

    return {
        x,
        y
    }
}
```

index.vue

```vue
<template>
    <p>mouse position {{x}} {{y}}</p>
</template>

<script>
import useMousePosition from './useMousePosition'

export default {
    name: 'MousePosition',
    setup() {
        const { x, y } = useMousePosition()
        return {
            x,
            y
        }
    }
}
</script>
```





### Vue3如何实现响应式

#### 回顾Vue2.x的Object.defineProperty

看上面：Vue原理 - 响应式

#### 学习Proxy语法

Proxy基本使用

```js
// const data = {
//     name: 'zhangsan',
//     age: 20,
// }
const data = ['a', 'b', 'c']

const proxyData = new Proxy(data, {
    get(target, key, receiver) {
        // 只处理本身（非原型的）属性
        const ownKeys = Reflect.ownKeys(target)
        if (ownKeys.includes(key)) {
            console.log('get', key) // 监听
        }

        const result = Reflect.get(target, key, receiver)
        return result // 返回结果
    },
    set(target, key, val, receiver) {
        // 重复的数据，不处理
        if (val === target[key]) {
            return true
        }

        const result = Reflect.set(target, key, val, receiver)
        console.log('set', key, val)
        // console.log('result', result) // true
        return result // 是否设置成功
    },
    deleteProperty(target, key) {
        const result = Reflect.deleteProperty(target, key)
        console.log('delete property', key)
        // console.log('result', result) // true
        return result // 是否删除成功
    }
})
```

Reflect的作用

- 和Proxy能力一一对应
- 规范化、标准化、函数式
- 替代掉Obejct上的工具函数，如Object.getOwnPropertyNames(obj) 可用 Reflect.ownKeys(obj) 来代替



#### Vue3如何用Proxy实现响应式

```js
// 创建响应式
function reactive(target = {}) {
    if (typeof target !== 'object' || target == null) {
        // 不是对象或数组，则返回
        return target
    }

    // 代理配置
    const proxyConf = {
        get(target, key, receiver) {
            // 只处理本身（非原型的）属性
            const ownKeys = Reflect.ownKeys(target)
            if (ownKeys.includes(key)) {
                console.log('get', key) // 监听
            }
    
            const result = Reflect.get(target, key, receiver)
        
            // 深度监听
            // 性能如何提升的？
            return reactive(result)
        },
        set(target, key, val, receiver) {
            // 重复的数据，不处理
            if (val === target[key]) {
                return true
            }
    
            const ownKeys = Reflect.ownKeys(target)
            if (ownKeys.includes(key)) {
                console.log('已有的 key', key)
            } else {
                console.log('新增的 key', key)
            }

            const result = Reflect.set(target, key, val, receiver)
            console.log('set', key, val)
            // console.log('result', result) // true
            return result // 是否设置成功
        },
        deleteProperty(target, key) {
            const result = Reflect.deleteProperty(target, key)
            console.log('delete property', key)
            // console.log('result', result) // true
            return result // 是否删除成功
        }
    }

    // 生成代理对象
    const observed = new Proxy(target, proxyConf)
    return observed
}

// 测试数据
const data = {
    name: 'zhangsan',
    age: 20,
    info: {
        city: 'beijing',
        a: {
            b: {
                c: {
                    d: {
                        e: 100
                    }
                }
            }
        }
    }
}

const proxyData = reactive(data)
```



#### Proxy实现响应式特点

- 深度监听，性能更好
- 可监听 新增/删除 属性
- 可监听数组变化
- Proxy能规避Object.defineProperty的问题
- 但是现在无法兼容所有浏览器，无法polyfill



### watch和watchEffect的区别是什么

- 两者都可监听data属性变化
- watch需要明确监听哪个属性
- watchEffect会根据其中的属性，自动监听其变化

#### watch

```js
setup() {
    const numberRef = ref(100)
    const state = reactive({
        name: 'ccc',
        age: 20
    })

    watch(numberRef, (newNumber, oldNumber) => {
        console.log('ref watch', newNumber, oldNumber)
    }
          // , {
          //     immediate: true // 初始化之前就监听，可选
          // }
         )

    setTimeout(() => {
        numberRef.value = 200
    }, 1500)

    watch(
        // 第一个参数，确定要监听哪个属性
        () => state.age,
        // 第二个参数，回调函数
        (newAge, oldAge) => {
            console.log('state watch', newAge, oldAge)
        },
        // 第三个参数，配置项
        {
            immediate: true, // 初始化之前就监听，可选
            // deep: true // 深度监听
        }
    )

    setTimeout(() => {
        state.age = 25
    }, 1500)
    setTimeout(() => {
        state.name = 'ccc'
    }, 3000)

    return {
        numberRef,
        ...toRefs(state)
    }
}
```



#### watchEffect

立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数

```js
setup() {
    const numberRef = ref(100)
    const state = reactive({
        name: 'ccc',
        age: 20
    })

    watchEffect(() => {
        // 初始化时，一定会执行一次（收集要监听的数据）
        console.log('state.age', state.age)
        console.log('state.name', state.name)
    })
    setTimeout(() => {
        state.age = 25
    }, 1500)
    setTimeout(() => {
        state.name = 'ccc'
    }, 3000)

    return {
        numberRef,
        ...toRefs(state)
    }
}
```



### setup中如何获取组件实例

- 在setup和其他Composition API中没有this
- 可通过getCurrentInstance获取当前实例
- 若使用Options API可照常使用this



### vue3为何比vue2快

可以在[Vue3 Templete Expolorer](https://vue-next-template-explorer.netlify.app/)源码编译尝试

#### Proxy响应式

#### PatchFlag（静态标记）

- 编译模板时，动态节点做标记
- 标记，分为不同的类型，如TEXT PROPS
- diff算法时，可以区分静态节点，以及不同类型的动态节点



![](..\picture\vue23diff对比.jpg)



#### hoistStatic

- 将静态节点的定义，提升到父作用域，缓存起来
- 多个相邻的静态节点，会被合并起来
- 典型的拿空间换时间的优化策略



#### cacheHandler（缓存事件）



#### SSR优化

- 静态节点直接输出，绕过了vdom
- 动态节点，还是需要动态渲染



#### tree-shaking

编译时，根据不同的情况，引入不同的API



### Vite是什么

- 一个前端打包工具，Vue作者发起的项目
- 借助Vue的影响力，发展较快，和webpack竞争
- 优势：开发环境下无需打包，启动快
  - 因为开发环境使用ES6 Module，无须打包  `<script type="module">`
  - 生产环境使用rollup，并不会快很多



### Composition API和React Hooks的对比

- 前者setup只会被调用一次，而后者函数会被多次调用
- 前者无需useMemo useCallback，因为setup只调用一次
- 前者无需顾虑调用顺序，而后者需要保证hooks的顺序一致
- 前者 reactive+ref 比后者 useState，要难理解





## React使用

### React基本使用

#### JSX语法

- 变量、表达式

  我们可以在JSX中使用JS表达式（不能适用于语句），表达式写在大括号“{}”中

  - `{2+2}`  `{user.firstName}`  `{formatName(user)}`

  - 在JSX中不能使用if-else语句，但可以使用conditional（三元运算）表达式来替代

    ```js
    const show = true;
    {show ? <img src="xxx.png"/> : ''}
    ```

  - 循环

    ```js
    const list = [1, 2, 3, 4, 5];
    {
        list.map((item, index) => {
            return <li key={index}>{item}</li>
        })
    }
    ```

- class style

  - React推荐使用内联样式。我们可以使用camelCase语法设置内联样式。

    React会在指定元素数字后自动添加px

    ```js
    var myStyle = {
        fontSize: 100,  // css中为font-size
        color: '#FF0000'
    };
    <h1 style={myStyle}>xxx</h1>
    ```

  - ```js
    <h1 style = {{background: red;}}>xxx</h1> //两个大括号
    ```

  - ```js
    .red-btn {
        background: red;
    }
    <h1 className='red-btn'>xxx</h1>  // 使用className而不是class
    ```

- 原生HTML

  ```js
  var item = `<h1>hello</h1>`
  <li
  	key={index}
  	onClick={this.handleItemDelete.bind(this, index)}
      dangerouslySetInnerHTML={__html: item}
  >
  </li>
  ```

#### 子元素和组件

#### 条件渲染

- if else

  ```js
  const whiteBtn = <button className="btn-white">white btn</button>
  const blackBtn = <button className="btn-black">black btn</button>
  
  if (this.state.theme === 'black') {
      return blackBtn
  } else {
      return whiteBtn
  }
  ```

- 三元表达式

  ```js
  return <div>
      { this.state.theme === 'black' ? blackBtn : whiteBtn }
  </div>
  ```

- 逻辑运算符 &&  ||

  ```js
  return <div>
      { this.state.theme === 'black' && blackBtn }
  </div>
  ```

- 列表渲染

  - map

    ```js
    class ListDemo extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                list: [
                    {
                        id: 'id1',
                        title: 'title1'
                    },
                    {
                        id: 'id2',
                        title: 'title2'
                    },
                    {
                        id: 'id3',
                        title: 'title3'
                    }
                ]
            }
        }
        render() {
            return <ul>{this.state.list.map((item, index) => {
                return <li key={item.id}>index {index}; title {item.title}</li>
            })}</ul>
        }
    }
    ```

  - key

#### 事件

- bind this

  ```js
  // 将这种作用域的修改放在constructor中，保证作用域绑定操作只执行一次。
  this.handleBtnClick = this.handleBtnClick.bind(this) //绑定this为对应组件<TodoList/>
  
  <button className="button" onClick={this.handleBtnClick}>提交</button>
  
  handleBtnClick() {
      // console.log(this)  // this默认是undefined
      this.setState({
          inputValue: ''
      })
  }
  
  // 用静态方法，this指向当前实力 不需要再绑定this
  handleBtnClick = () => {
      this.setState({
          inputValue: ''
      })
  }
  ```

- 关于event参数

  ```js
  handleBtnClick = (event) => {
      event.preventDefault()  // 阻止默认行为
      event.stopPropagation() // 阻止冒泡
      console.log('target', event.target)  // 指向当前元素，即当前元素触发
      console.log('current target', event.currentTarget) // 指向当前元素，假象！
      
      // 注意，event其实是React封装的。可以看__proto__constructor是 SyntheticEvent
      conole.log('event', event)
      
      // 原生event（event.nativeEvent）如下。其__proto__constructor是 MouseEvent
      console.log('NativeEvent', event.nativeEvent)
      console.log('NativeEvent target', event.nativeEvent.target) //指向当前元素
      console.log('NativeEvent current target', event.nativeEvent.currentTarget)
  	// 指向document元素/root组件
  }
  ```

  **版本升级**

  React16绑定到document

  **React17事件绑定到root组件**

  有利于多个React版本并存，例如微前端

- 传递自定义参数

  ```js
  <button className="button" onClick={this.handleBtnClick(id, title)}>提交</button>
  
  handleBtnClick(id, title, event) {
      console.log(id, title)
      console.log('event', event)  // 最后追加一个参数，即可接收event
  }
  ```

#### 表单

- 受控组件

  ```js
  render() {
      return <div>
          <p>{this.state.name}</p>
          <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for */}
          <input id="inputName" value={this.state.name} onChange={this.onInputChange}/>
      </div>
  }
  onInputChange = (e) => {
      this.setState({
          name: e.target.value
      })
  }
  ```

- input textarea select 用value

- checkbox radio 用checked

- 组件和props（类型检查）

  - props传递数据
  - props传递函数
  - props类型检查

  ```js
  import React from 'react'
  import PropTypes from 'prop-types'
  
  class Input extends React.Component {
      constructor(props) {
          super(props)
          this.state = {
              title: ''
          }
      }
      render() {
          return <div>
              <input value={this.state.title} onChange={this.onTitleChange}/>
              <button onClick={this.onSubmit}>提交</button>
          </div>
      }
      onTitleChange = (e) => {
          this.setState({
              title: e.target.value
          })
      }
      onSubmit = () => {
          const { submitTitle } = this.props
          submitTitle(this.state.title) // 'abc'
  
          this.setState({
              title: ''
          })
      }
  }
  // props 类型检查
  Input.propTypes = {
      submitTitle: PropTypes.func.isRequired
  }
  
  class List extends React.Component {
      constructor(props) {
          super(props)
      }
      render() {
          const { list } = this.props
  
          return <ul>{list.map((item, index) => {
              return <li key={item.id}>
                  <span>{item.title}</span>
              </li>
          })}</ul>
      }
  }
  // props 类型检查
  List.propTypes = {
      list: PropTypes.arrayOf(PropTypes.object).isRequired
  }
  
  class Footer extends React.Component {
      constructor(props) {
          super(props)
      }
      render() {
          return <p>
              {this.props.text}
              {this.props.length}
          </p>
      }
      componentDidUpdate() {
          console.log('footer did update')
      }
      shouldComponentUpdate(nextProps, nextState) {
          if (nextProps.text !== this.props.text
              || nextProps.length !== this.props.length) {
              return true // 可以渲染
          }
          return false // 不重复渲染
      }
  
      // React 默认：父组件有更新，子组件则无条件也更新！！！
      // 性能优化对于 React 更加重要！
      // SCU 一定要每次都用吗？—— 需要的时候才优化
  }
  
  class TodoListDemo extends React.Component {
      constructor(props) {
          super(props)
          // 状态（数据）提升
          this.state = {
              list: [
                  {
                      id: 'id-1',
                      title: '标题1'
                  },
                  {
                      id: 'id-2',
                      title: '标题2'
                  },
                  {
                      id: 'id-3',
                      title: '标题3'
                  }
              ],
              footerInfo: '底部文字'
          }
      }
      render() {
          return <div>
              <Input submitTitle={this.onSubmitTitle}/>
              <List list={this.state.list}/>
              <Footer text={this.state.footerInfo} length={this.state.list.length}/>
          </div>
      }
      onSubmitTitle = (title) => {
          this.setState({
              list: this.state.list.concat({
                  id: `id-${Date.now()}`,
                  title
              })
          })
      }
  }
  
  export default TodoListDemo
  ```

#### state和setState（重点）

- 不可变值

  ```js
  // 不可变值（函数式编程，纯函数） - 数组
  const list5Copy = this.state.list5.slice()
  list5Copy.splice(2, 0, 'a') // 中间插入/删除
  this.setState({
      list1: this.state.list1.concat(100), // 追加
      list2: [...this.state.list2, 100], // 追加
      list3: this.state.list3.slice(0, 3), // 截取
      list4: this.state.list4.filter(item => item > 100), // 筛选
      list5: list5Copy // 其他操作
  })
  // 注意，不能直接对 this.state.list 进行 push pop splice 等，这样违反不可变值
  ```

  

- 可能是异步更新

  ```js
  this.setState({
      count: this.state.count + 1
  }, () => {
      // 联想 Vue $nextTick - DOM
      console.log('count by callback', this.state.count) // 回调函数中可以拿到最新的 state
  })
  console.log('count', this.state.count) // 异步的，拿不到最新值
  ```

  ```js
  // setTimeout 中 setState 是同步的
  setTimeout(() => {
      this.setState({
          count: this.state.count + 1
      })
      console.log('count in setTimeout', this.state.count)
  }, 0)
  ```

  ```js
  // 自己定义的 DOM 事件，setState 是同步的
  bodyClickHandler = () => {
      this.setState({
          count: this.state.count + 1
      })
      console.log('count in body event', this.state.count)
  }
  componentDidMount() {
      // 自己定义的 DOM 事件，setState 是同步的
      document.body.addEventListener('click', this.bodyClickHandler)
  }
  componentWillUnmount() {
      // 及时销毁自定义 DOM 事件
      document.body.removeEventListener('click', this.bodyClickHandler)
      // clearTimeout
  }
  ```

- 可能会被合并

  ```js
  // 传入对象，会被合并（类似 Object.assign ）。执行结果只一次 +1
  this.setState({
      count: this.state.count + 1
  })
  this.setState({
      count: this.state.count + 1
  })
  this.setState({
      count: this.state.count + 1
  })
  
  // 传入函数，不会被合并。执行结果是 +3
  this.setState((prevState, props) => {
      return {
          count: prevState.count + 1
      }
  })
  this.setState((prevState, props) => {
      return {
          count: prevState.count + 1
      }
  })
  this.setState((prevState, props) => {
      return {
          count: prevState.count + 1
      }
  })
  ```

#### 组件生命周期

[React 组件生命周期图示](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

- constructor：在组件一创建的时刻就被调用。但不归类在React的生命周期中，因为它是ES6里面的东西，不是React独有的。
- componentWillMount：在组件即将被挂载到页面的时刻自动执行。
- componentDidMount：在组件被挂载后自动执行。
- shouldComponentUpdate：组件被更新之前，自动被执行需要返回一个布尔值。true 更新 false 不会被更新
- componentWillUpdate：组件被更新之前，它会自动执行，但是它在shouldComponentUpdate之后被执行，如果返回true就执行，如果返回false，这个函数就不会被执行了。
- componentDidUpdate：组件被更新之后自动执行。
- componentWillReceiveProps：一个组件要从父组件接受参数。只要父组件的render函数被重新执行了，子组件的这个生命周期函数就会被执行（如果这个组件第一次存在与父组件中，不会执行；如果这个组件之前已经存在于父组件中，才会执行）
- componentWillUnmount：当这个组件即将被从页面中剔除的时候，会被执行。



### React高级特性

#### 函数组件

- 纯函数，输入props，输出JSX
- 没有组件实例
- 没有生命周期
- 没有state和setState，只能接收props
- 不能扩展其他方法

#### 非受控组件

- ref
- defaultValue defaultChecked
- 手动操作DOM元素
- 使用场景：必须手动操作DOM 元素，setState实现不了的。如文件上传、某些富文本编辑器，需要传入DOM元素

```js
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: '双越',
            flag: true,
        }
        this.nameInputRef = React.createRef() // 创建 ref
    }
    render() {
        // input defaultValue
        return <div>
            {/* 使用 defaultValue 而不是 value ，使用 ref */}
            <input defaultValue={this.state.name} ref={this.nameInputRef}/>
            {/* state 并不会随着改变 */}
            <span>state.name: {this.state.name}</span>
            <br/>
            <button onClick={this.alertName}>alert name</button>
        </div>

    }
    alertName = () => {
        const elem = this.nameInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.value) // 不是 this.state.name
    }
}

export default App
```

```js
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.fileInputRef = React.createRef()
    }
    render() {
        // file
        return <div>
            <input type="file" ref={this.fileInputRef}/>
            <button onClick={this.alertFile}>alert file</button>
        </div>

    }
    alertFile = () => {
        const elem = this.fileInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.files[0].name)
    }
}

export default App
```

受控组件VS非受控组件

优先使用受控组件，符合React设计原则；必须操作DOM时，再使用非受控组件

- Portals

  - 组件默认会按照既定层次嵌套渲染
  - 如何让组件渲染到父组件以外
  - 使用场景
    - overflow: hidden
    - 父组件z-index值太小
    - fixed需要放在body第一层级

  ```js
  import React from 'react'
  import ReactDOM from 'react-dom'
  import './style.css'
  
  class App extends React.Component {
      constructor(props) {
          super(props)
          this.state = {
          }
      }
      render() {
          // // 正常渲染
          // return <div className="modal">
          //     {this.props.children} {/* vue slot */}
          // </div>
  
          // 使用 Portals 渲染到 body 上。
          // fixed 元素要放在 body 上，有更好的浏览器兼容性。
          return ReactDOM.createPortal(
              <div className="modal">{this.props.children}</div>,
              document.body // DOM 节点
          )
      }
  }
  
  export default App
  ```

#### context

- 公共信息（语言、主题）传递给每个组件

```js
import React from 'react'

// 创建 Context 填入默认值（任何一个 js 变量）
const ThemeContext = React.createContext('light')

// 底层组件 - 函数是组件
function ThemeLink (props) {
    // const theme = this.context // 会报错。函数式组件没有实例，即没有 this

    // 函数式组件可以使用 Consumer
    return <ThemeContext.Consumer>
        { value => <p>link's theme is {value}</p> }
    </ThemeContext.Consumer>
}

// 底层组件 - class 组件
class ThemedButton extends React.Component {
    // 指定 contextType 读取当前的 theme context。
    // static contextType = ThemeContext // 也可以用 ThemedButton.contextType = ThemeContext
    render() {
        const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。
        return <div>
            <p>button's theme is {theme}</p>
        </div>
    }
}
ThemedButton.contextType = ThemeContext // 指定 contextType 读取当前的 theme context。

// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar(props) {
    return (
        <div>
            <ThemedButton />
            <ThemeLink />
        </div>
    )
}

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            theme: 'light'
        }
    }
    render() {
        return <ThemeContext.Provider value={this.state.theme}>
            <Toolbar />
            <hr/>
            <button onClick={this.changeTheme}>change theme</button>
        </ThemeContext.Provider>
    }
    changeTheme = () => {
        this.setState({
            theme: this.state.theme === 'light' ? 'dark' : 'light'
        })
    }
}

export default App
```

#### 异步组件

- import()
- React.lazy
- React.Suspense

```js
import React from 'react'

const ContextDemo = React.lazy(() => import('./ContextDemo'))

class App extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return <div>
            <p>引入一个动态组件</p>
            <hr />
            <React.Suspense fallback={<div>Loading...</div>}>
                <ContextDemo/>
            </React.Suspense>
        </div>

        // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速）
        // 2. 看 network 的 js 加载
    }
}

export default App
```

#### 性能优化

- shouldComponentUpdate（简称SCU）

  ```js
  shouldComponentUpdate(nextProps, nextState) {
      if (nextState.count !== this.state.count) {
          return true // 可以渲染
      }
      return false // 不重复渲染
  }
  ```

  React 默认：父组件有更新，子组件则无条件也更新

  SCU默认返回true

  性能优化对于 React 更加重要

  

- PureComponent和React.memo

  - PureComponent SCU中实现了浅比较

  - memo 函数组件中的PureComponent 

    ```js
    function MyComponent(props) {
        // 使用props渲染
    }
    function areEqual(prevProps, nextProps) {
        /* 如果把nextProps传入render方法的返回结果与
        	将prevProps传入render方法的返回结果一致则返回true
        	否则返回false
        */
    }
    export default React.memo(MyComponent, areEqual)
    ```

  - 浅比较已使用大部分情况（尽量不要做深度比较）

- 不可变值 immutable.js

- 高阶组件HOC

  基本使用

  ```js
  // 高阶组件不是一种功能，而是一种模式
  const HOCFactory = (Component) => {
      class HOC extends React.Component {
          render() {
              // 返回拼装的结果
              return <Component {...this.props}/> 
          }
      }
      return HOC
  }
  const EnhancesComponent1 = HOCFactory(WrappedComponent1)
  const EnhancesComponent2 = HOCFactory(WrappedComponent2)
  ```

  例子

  ```js
  import React from 'react'
  
  // 高阶组件
  const withMouse = (Component) => {
      class withMouseComponent extends React.Component {
          constructor(props) {
              super(props)
              this.state = { x: 0, y: 0 }
          }
    
          handleMouseMove = (event) => {
              this.setState({
                  x: event.clientX,
                  y: event.clientY
              })
          }
    
          render() {
              return (
                  <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
                      {/* 1. 透传所有 props 2. 增加 mouse 属性 */}
                      <Component {...this.props} mouse={this.state}/>
                  </div>
              )
          }
      }
      return withMouseComponent
  }
  
  const App = (props) => {
      const a = props.a
      const { x, y } = props.mouse // 接收 mouse 属性
      return (
          <div style={{ height: '500px' }}>
              <h1>The mouse position is ({x}, {y})</h1>
              <p>{a}</p>
          </div>
      )
  }
  
  export default withMouse(App) // 返回高阶函数
  ```

  - redux connect 是高阶组件

    ```js
    import { connect } from 'react-redux'
    // connect是高阶组件
    const VisibleTodoList = connect(
    	mapStateToProps,
        mapDispatchToProps
    )(TodoList)
    
    export default VisibleTodolList
    ```

    


#### Render Props

基本使用

```js
// Render Props的核心思想
// 通过一个函数将class组件的state作为props传递给纯函数组件
class Factory extends React.Component {
    constructor() {
        this.state = {
            // state即多个组件的公共逻辑的数据
        }
    }
    // 修改state
    render() {
        return <div>{this.props.render(this.state)}</div>
    }
}

const App = () => (
    <Factory render={
        // render是一个函数组件
        (props)=> <p>{props.a} {props.b} ... </p>
    }/>
)
```

例子

```js
import React from 'react'
import PropTypes from 'prop-types'

class Mouse extends React.Component {
    constructor(props) {
        super(props)
        this.state = { x: 0, y: 0 }
    }
  
    handleMouseMove = (event) => {
      this.setState({
        x: event.clientX,
        y: event.clientY
      })
    }
  
    render() {
      return (
        <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
            {/* 将当前 state 作为 props ，传递给 render （render 是一个函数组件） */}
            {this.props.render(this.state)}
        </div>
      )
    }
}
Mouse.propTypes = {
    render: PropTypes.func.isRequired // 必须接收一个 render 属性，而且是函数
}

const App = (props) => (
    <div style={{ height: '500px' }}>
        <p>{props.a}</p>
        <Mouse render={
            /* render 是一个函数组件 */
            ({ x, y }) => <h1>The mouse position is ({x}, {y})</h1>
        }/>
        
    </div>
)

/**
 * 即，定义了 Mouse 组件，只有获取 x y 的能力。
 * 至于 Mouse 组件如何渲染，App 说了算，通过 render props 的方式告诉 Mouse 。
 */

export default App
```

HOC VS Render Props

- HOC：模式简单 但会增加组件层级
- Render Props：代码简洁，学习成本较高
- 按需使用



### Redux使用

**基本概念**

具体看[react基础 - redux](../前端基础汇总/react基础.md)

- store state
- action
- reducer

**单向数据流**

- dispatch(action)
- reducer => newState
- subscribe触发通知

**react-redux**

- Provider：作用：连接store，内部组件都有能力获取store的内容

- connect：组件与store作连接

- mapStateToProps：把store中state映射成组件中的props

- mapDispatchToProps：将store.dispatch挂载到props上

**异步action**

```js
// 同步action
export const addTodo = text => {
    // 返回action对象
    return {
        type: 'ADD_TODO',
        id: nextTodoId++,
        text
    }
}
```

```js
// 异步action
export const addTodoAsync = text => {
    // 返回函数，其中有dispatch参数
    return (dispatch) => {
        // ajax 异步获取数据
        fetch(url).then(res => {
            // 执行异步 action
            dispatch(addTodo(res.text))
        })
    }
}
```

**中间件**

**redux数据流图**

![redux数据流图](..\picture\redux数据流图.jpg)

### React-router使用

- 路由模式（hash、H5 history），同vue-router
- 路由配置（动态路由、懒加载），同vue-router

![react-router路由模式](..\picture\react-router路由模式.jpg)

![react-router动态路由](..\picture\react-router动态路由.jpg)

![react-router跳转路由](..\picture\react-router跳转路由.jpg)

![react-router懒加载](..\picture\react-router懒加载.jpg)



## React原理

### 函数式编程

- 纯函数
- 不可变值

### vdom和diff

以上述vue中类似

vdom

- h函数
- vnode数据结构
- patch函数

diff

- 只比较同一层级，不跨级比较
- tag不相同，则直接删掉重建，不再深度比较
- tag和key，两者都相同，则认为是相同节点，不再深度比较

### JSX本质

```js
const imgElem = <div id="div1">
    <p>some text</p>
	<img src={imgUrl} />
</div>


// 编译后
React.createElement("div", {
    id: "div1"
}, React.createElement("p", null, "some text"), React.createElement("img", {
    src: imgUrl
}))
```

### 合成事件

React16

- 所有事件挂载到document上
- event不是原生的，是SyntheticEvent合成事件对象
- 和Vue事件不同，和DOM事件也不同

为何要合成事件机制？

- 更好的兼容性和跨平台
- 挂载到document，减少内存消耗，避免频繁解绑
- 方便事件的统一管理（如事务机制）



React17

- 绑定到root组件上
- 有利于多个React版本并存，例如微前端



### setState 和 batchUpdate

setState异步还是同步？

- 无所谓同步还是异步
- 看是否能命中batchUpdate机制
- 判断isBatchingUpdates

#### setState主流程

![setState主流程](..\picture\setState主流程.jpg)

#### batchUpdate机制

**isBatchingUpdates**

![isBatchingUpdates](..\picture\isBatchingUpdates.jpg)



哪些能命中batchUpdate机制

- 生命周期（和它调用的函数）
- React中注册的事件（和它调用的函数）
- React可以“管理”的入口

哪些不能命中batchUpdate机制

- setTimeout setInterval等（和它调用的函数）
- 自定义的DOM事件（和它调用的函数）
- React“管不到”的入口



#### transaction（事务）机制

![transaction事务机制](..\picture\transaction事务机制.jpg)





### 组件渲染过程

- props state
- render() 生成 vnode
- patch(elem, vnode)

组件更新过程

- setState(newState) => dirtyComponents（可能有子组件）
- render() 生成 newVnode
- patch(vnode, newVnode)

patch拆分成两个阶段：

1、reconciliation阶段：执行diff算法，纯JS计算

2、commit阶段：将diff结果渲染DOM



可能会有性能问题

- JS是单线程，且和DOM渲染共用一个线程
- 当组件足够复杂，组件更新时计算和渲染都压力大
- 同时再有DOM操作需求（动画，鼠标拖拽等），将卡顿



性能优化解决方案：react-fiber

- 将reconciliation阶段进行任务拆分成子任务
- 子任务的执行在DOM需要渲染时暂停，空闲时恢复
- window.requestIdleCallback



### 面试真题演练

#### 组件之间如何通讯

- 父子组件props
- 自定义事件
- Redux和Context

#### JSX本质是什么

- createElement
- 执行返回vnode

#### React发起ajax应该在哪个生命周期

- 同Vue
- componentDidMount

#### 渲染列表为何使用key

- 同Vue。必须用key，且不能是index和random
- diff算法中通过tag和key来判断是否是sameNode
- 减少渲染次数，提升渲染性能

#### 多个组件有公共逻辑，如何抽离

- 高阶组件
- Render Props
- mixin 已被React废弃

#### React性能优化

- 渲染列表时加key
- 自定义事件、DOM事件及时销毁
- 合理使用异步组件
- 减少函数 bind this 的次数
- 合理使用SCU PureComponent 和memo
- 合理使用Immutable.js
- webpack层面的优化
- 前端通用的性能优化，如图片懒加载
- 使用SSR

#### React和Vue的区别

- 都支持组件化
- 都是数据驱动视图
- 都使用vdom操作DOM

- React使用JSX拥抱JS，Vue使用模板拥抱html

- React函数式编程，Vue声明式编程
- React需要更多的自力更生，Vue把想要的都给你



## React Hooks

### 几个面试题

#### 为什么会有React Hooks，它解决了哪些问题

- 完善函数组件的能力，函数组件更适合React组件
- 组件逻辑复用，Hooks表现更好，使用Hooks，相同逻辑可分割到一个一个的useEffect中，而不是像class组件一样，分布在各个生命周期中
- class复杂组件正在变得费解，不易吃阿杰，不易测试，逻辑混乱

**class组件的问题**

- 大型组件很难拆分和重构，很难测试（即class不易拆分）
- 相同业务逻辑，分散到各个方法中，逻辑混乱
- 复用逻辑变得复杂，如Mixins，HOC，Render Prop

所以函数组件更适合React组件，但需要Hooks增强功能



#### React Hooks 如何模拟组件生命周期

- 模拟 componentDidMount - useEffect 依赖 []

- 模拟 componentDidUpdate - useEffect 无依赖， 或者依赖 [a, b]

- 模拟 componentWillUnMount - useEffect 中返回一个函数

  - useEffect依赖[]，组件销毁时执行fn，等于WillUnMounted

  - useEffect无依赖或依赖[a, b]，组件更新时执行fn

  - 即，下一次执行useEffect之前，就会执行fn，无论更新或卸载

    

#### 如何自定义 Hook



#### React Hooks 是性能优化

- useMemo缓存数据，useCallback缓存函数

- 相当于class组件的SCU和PureComponent



#### 使用 React Hooks 遇到哪些坑

- useState初始化值，只有第一次有效

- useEffect内部不能修改state

- useEffect可能出现死循环

  

#### Hooks 相比 HOC 和 Render Prop 有哪些优点

- 完全符合Hooks原有规则，没有其他要求，易理解记忆
- 变量作用域明确
- 不会产生组件嵌套





### State Hook

#### 作用：让函数组件实现 state 和 setState

- 默认函数组件没有state
- 函数组件是一个纯函数，执行完即销毁，无法存储state
- 需要State Hook，即把state功能“钩”到纯函数中

#### useState使用总结

- `useState(0)`传入初始值，返回数组[state, setState]
- 通过state获取值
- 通过`setState(1)`修改值

#### Hooks命名规范

- 规定所有的Hooks都用use开头，如useXxx
- 自定义Hook也要以use开头
- 非Hooks的地方，尽量不要使用useXxx写法

#### 代码演示

```js
import React, { useState } from 'react'

function ClickCounter() {
    // 数组的解构
    // useState 就是一个 Hook “钩”，最基本的一个 Hook
    const [count, setCount] = useState(0) // 传入一个初始值

    function clickHandler() {
        setCount(count + 1)
    }

    return <div>
        <p>你点击了 {count} 次</p>
        <button onClick={clickHandler}>点击</button>
    </div>
}

export default ClickCounter
```



### Effect Hook

#### 作用：让组件模拟生命周期

- 默认函数组件没有生命周期
- 函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期
- 使用Effect Hook 把生命周期“钩”到纯函数中

#### useEffect使用总结

- 模拟 componentDidMount - useEffect 依赖 []

- 模拟 componentDidUpdate - useEffect 无依赖， 或者依赖 [a, b]

- 模拟 componentWillUnMount - useEffect 中返回一个函数fn

  - useEffect依赖[]，组件销毁时执行fn，等于WillUnMounted
  - useEffect无依赖或依赖[a, b]，组件更新时执行fn
  - 即，下一次执行useEffect之前，就会执行fn，无论更新或卸载

  

#### 代码演示

```js
import React, { useState, useEffect } from 'react'

function LifeCycles() {
    const [count, setCount] = useState(0)

    // 模拟 class 组件的 DidMount 和 DidUpdate
    useEffect(() => {
        console.log('在此发送一个 ajax 请求')
    })

    // 模拟 class 组件的 DidMount
    useEffect(() => {
        console.log('加载完了')
    }, []) // 第二个参数是 [] （不依赖于任何 state）

    // 模拟 class 组件的 DidUpdate
    useEffect(() => {
        console.log('更新了')
    }, [count]) // 第二个参数就是依赖的 state

    // 模拟 class 组件的 DidMount
    useEffect(() => {
        let timerId = window.setInterval(() => {
            console.log(Date.now())
        }, 1000)

        // 返回一个函数
        // 模拟 WillUnMount
        return () => {
            window.clearInterval(timerId)
        }
    }, [])

    function clickHandler() {
        setCount(count + 1)
    }

    return <div>
        <p>你点击了 {count} 次</p>
        <button onClick={clickHandler}>点击</button>
    </div>
}

export default LifeCycles
```

#### 模拟WillUnMount，但不完全相等

- useEffect依赖[]，组件销毁时执行fn，等于WillUnMounted
- useEffect无依赖或依赖[a, b]，组件更新时执行fn
- 即，下一次执行useEffect之前，就会执行fn，无论更新或卸载

```js
import React, { useState, useEffect } from 'react'

function FriendStatus({ friendId }) {
    const [status, setStatus] = useState(false)

    // DidMount 和 DidUpdate
    useEffect(() => {
        console.log(`开始监听 ${friendId} 在线状态`)

        // 【特别注意】
        // 此处并不完全等同于 WillUnMount
        // props 发生变化，即更新，也会执行结束监听
        // 准确的说：返回的函数，会在下一次 effect 执行之前，被执行
        return () => {
            console.log(`结束监听 ${friendId} 在线状态`)
        }
    })

    return <div>
        好友 {friendId} 在线状态：{status.toString()}
    </div>
}

export default FriendStatus
```





### 其他 Hook

#### useRef

```js
import React, { useRef, useEffect } from 'react'

function UseRef() {
    const btnRef = useRef(null) // 初始值

    // const numRef = useRef(0)
    // numRef.current

    useEffect(() => {
        console.log(btnRef.current) // DOM 节点
    }, [])

    return <div>
        <button ref={btnRef}>click</button>
    </div>
}

export default UseRef
```



#### useContext

```js
import React, { useContext } from 'react'

// 主题颜色
const themes = {
    light: {
        foreground: '#000',
        background: '#eee'
    },
    dark: {
        foreground: '#fff',
        background: '#222'
    }
}

// 创建 Context
const ThemeContext = React.createContext(themes.light) // 初始值

function ThemeButton() {
    const theme = useContext(ThemeContext)

    return <button style={{ background: theme.background, color: theme.foreground }}>
        hello world
    </button>
}

function Toolbar() {
    return <div>
        <ThemeButton></ThemeButton>
    </div>
}

function App() {
    return <ThemeContext.Provider value={themes.dark}>
        <Toolbar></Toolbar>
    </ThemeContext.Provider>
}

export default App
```



#### useReducer

```js
import React, { useReducer } from 'react'

const initialState = { count: 0 }

const reducer = (state, action) => {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 }
        case 'decrement':
            return { count: state.count - 1 }
        default:
            return state
    }
}

function App() {
    // 很像 const [count, setCount] = useState(0)
    const [state, dispatch] = useReducer(reducer, initialState)

    return <div>
        count: {state.count}
        <button onClick={() => dispatch({ type: 'increment' })}>increment</button>
        <button onClick={() => dispatch({ type: 'decrement' })}>decrement</button>
    </div>
}

export default App
```

##### useReducer 和 redux 的区别

- useReducer是useState的代替方案，用于state复杂变化
- useReducer是单个组件状态管理，组件通讯还需要props
- redux是全局的状态管理，多组件共享数据



#### useMemo

##### useMemo使用总结

- React默认会更新所有子组件
- class组件使用SCU和PureComponent做优化
- Hooks中使用useMemo，但优化的原理是相同的
- memo封装子组件，useMemo封装数据

```js
import React, { useState, memo, useMemo } from 'react'

// 子组件
// 类似 class PureComponent ，对 props 进行浅层比较
const Child = memo(({ userInfo }) => {
    console.log('Child render...', userInfo)

    return <div>
        <p>This is Child {userInfo.name} {userInfo.age}</p>
    </div>
})

// 父组件
function App() {
    console.log('Parent render...')

    const [count, setCount] = useState(0)
    const [name, setName] = useState('双越老师')

    // const userInfo = { name, age: 20 }
    // 用 useMemo 缓存数据，有依赖
    const userInfo = useMemo(() => {
        return { name, age: 21 }
    }, [name])

    return <div>
        <p>
            count is {count}
            <button onClick={() => setCount(count + 1)}>click</button>
        </p>
        <Child userInfo={userInfo}></Child>
    </div>
}

export default App
```



#### useCallback

**useMemo缓存数据，useCallback缓存函数**

```js
import React, { useState, memo, useMemo, useCallback } from 'react'

// 子组件，memo 相当于 PureComponent
const Child = memo(({ userInfo, onChange }) => {
    console.log('Child render...', userInfo)

    return <div>
        <p>This is Child {userInfo.name} {userInfo.age}</p>
        <input onChange={onChange}></input>
    </div>
})

// 父组件
function App() {
    console.log('Parent render...')

    const [count, setCount] = useState(0)
    const [name, setName] = useState('双越老师')

    // 用 useMemo 缓存数据
    const userInfo = useMemo(() => {
        return { name, age: 21 }
    }, [name])

    // function onChange(e) {
    //     console.log(e.target.value)
    // }
    // 用 useCallback 缓存函数
    const onChange = useCallback(e => {
        console.log(e.target.value)
    }, [])

    return <div>
        <p>
            count is {count}
            <button onClick={() => setCount(count + 1)}>click</button>
        </p>
        <Child userInfo={userInfo} onChange={onChange}></Child>
    </div>
}

export default App
```



### 自定义 Hook

#### 自定义useAxios

```js
import { useState, useEffect } from 'react'
import axios from 'axios'

// 封装 axios 发送网络请求的自定义 Hook
function useAxios(url) {
    const [loading, setLoading] = useState(false)
    const [data, setData] = useState()
    const [error, setError] = useState()

    useEffect(() => {
        // 利用 axios 发送网络请求
        setLoading(true)
        axios.get(url) // 发送一个 get 请求
            .then(res => setData(res))
            .catch(err => setError(err))
            .finally(() => setLoading(false))
    }, [url])

    return [loading, data, error]
}

export default useAxios

// 第三方 Hook
// https://nikgraf.github.io/react-hooks/
// https://github.com/umijs/hooks
```

```js
import React from 'react'
import useAxios from '../customHooks/useAxios'

function App() {
    const url = 'http://localhost:3000/'
    // 数组解构
    const [loading, data, error] = useAxios(url)

    if (loading) return <div>loading...</div>

    return error
        ? <div>{JSON.stringify(error)}</div>
        : <div>{JSON.stringify(data)}</div>
}

export default App
```



#### 自定义useMousePosition

```js
import { useState, useEffect } from 'react'

function useMousePosition() {
    const [x, setX] = useState(0)
    const [y, setY] = useState(0)

    useEffect(() => {
        function mouseMoveHandler(event) {
            setX(event.clientX)
            setY(event.clientY)
        }

        // 绑定事件
        document.body.addEventListener('mousemove', mouseMoveHandler)

        // 解绑事件
        return () => document.body.removeEventListener('mousemove', mouseMoveHandler)
    }, [])

    return [x, y]
}

export default useMousePosition
```

```js
import React from 'react'
import useMousePosition from '../customHooks/useMousePosition'

function App() {
    const [x, y] = useMousePosition()
    return <div style={{ height: '500px', backgroundColor: '#ccc' }}>
        <p>鼠标位置 {x} {y}</p>
    </div>
}

export default App
```



### Hooks 使用规范

- 只能用于React函数组件和自定义Hook中，其他地方不可以
- 只能用于顶层代码，不能在循环、判断中使用Hooks（Hooks严重依赖于调用顺序，如果Hooks出现在循环、判断里，则无法保证顺序一致）
- eslint插件eslint-plugin-resct-hooks可以帮到你



### 规范和注意事项

- useState初始化值，只有第一次有效

  - render: 初始化 state
  - re-render: 只恢复初始化的 state 值，不会再重新设置新的值。只能用 setName 修改

  ```js
  import React, { useState } from 'react'
  
  // 子组件
  function Child({ userInfo }) {
      // render: 初始化 state
      // re-render: 只恢复初始化的 state 值，不会再重新设置新的值
      //            只能用 setName 修改
      const [ name, setName ] = useState(userInfo.name)
  
      return <div>
          <p>Child, props name: {userInfo.name}</p>	/* 点击后会改变 */
          <p>Child, state name: {name}</p>			/* 点击后不会改变 */
      </div>
  }
  
  
  function App() {
      const [name, setName] = useState('双越')
      const userInfo = { name }
  
      return <div>
          <div>
              Parent &nbsp;
              <button onClick={() => setName('慕课网')}>setName</button>
          </div>
          <Child userInfo={userInfo}/>
      </div>
  }
  
  export default App
  ```

- useEffect内部不能修改state
  - 依赖为 [] 时： re-render 不会重新执行 effect 函数
  - 没有依赖：re-render 会重新执行 effect 函数
- useEffect可能出现死循环
  - 当依赖中有引用对象时，会出现死循环
  - 使用useRef来解决

```js
import React, { useState, useRef, useEffect } from 'react'

function UseEffectChangeState() {
    const [count, setCount] = useState(0)

    // 模拟 DidMount
    const countRef = useRef(0)
    useEffect(() => {
        console.log('useEffect...', count)

        // 定时任务
        const timer = setInterval(() => {
            console.log('setInterval...', countRef.current)
            // setCount(count + 1)
            setCount(++countRef.current)
        }, 1000)

        // 清除定时任务
        return () => clearTimeout(timer)
    }, []) // 依赖为 []

    // 依赖为 [] 时： re-render 不会重新执行 effect 函数
    // 没有依赖：re-render 会重新执行 effect 函数

    return <div>count: {count}</div>
}

export default UseEffectChangeState
```







## webpack 和 babel







## 项目流程

- PM想在项目开发过程中增加需求，该怎么办
  - 不能拒绝，走需求变更流程即可
  - 如果公司有规定就按规定走，否则，发起项目组和leader的评审，重新评估排期
- 项目即将延期了，该怎么办
- 你将如何保证项目质量

### 项目角色

- PM产品经理
- UE视觉设计师
- FE前端开发
- RD后端开发
- CRD移动端开发
- QA测试人员

### 完整项目流程

- 需求分析（各个角色）
- 技术方案设计（FE RD CRD）
- 开发（FE）
- 联调（FE RD CRD）
- 测试（FE QA）
- 上线（FE）

















