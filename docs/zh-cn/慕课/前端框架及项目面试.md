# 前端框架及项目面试

## 面试题

### Vue面试题

- v-show和v-if的区别
- 为何v-for中要用key
- 描述Vue组件生命周期（有父子组件的情况）
- Vue组件如何通讯
- 描述组件渲染和更新的过程
- 双向数据绑定v-model的实现原理

### react面试题

- react组件如何通讯

- JSX本质是什么

- context是什么，有何用途

- shouldComponentUpdate的用途

- 描述redux单向数据流

- setState是同步还是异步（场景见下图）  0 0 1 2 ？

  ![](..\picture\setState异步.png)

### 框架综合应用

- 基于react设计一个todolist（组件结构，redux state数据结构）
- 基于Vue设计一个购物车（组件结构，Vuex state数据结构）

### webpack面试题

- 前端代码为何要进行构建和打包
- module chunk bundle 分别是什么意思，有何区别
- loader和plugin的区别
- webpack如何实现懒加载
- webpack常见性能优化
- babel-runtime和babel-polyfill的区别

## Vue使用

### Vue基本使用

- 插值表达式

- 指令、动态属性

- v-html：会有XSS风险，会覆盖子组件

- computed和watch

  - computed有缓存，data不变则不会重新计算
  - watch如何深度监听？
  - watch监听引用类型，拿不到oldVal

- class和style

  - 使用动态属性
  - 使用驼峰式写法

- 条件渲染

  - v-if v-else 的用法，可使用变量，也可以使用 === 表达式
  - v-if 和 v-show 的区别？
  - v-if 和 v-show 的使用场景？数据改变频繁用 v-show

- 列表渲染

  - 如何遍历对象？也可以用v-for

  - key的重要性，key不能乱写（如random或者index）

  - v-for 和 v-if 不能一起使用

    v-for比v-if的优先级更高，这就说明在v-for的每次循环运行中每一次都会调用v-if的判断，所以不推荐v-if和v-for在同一个标签内同时使用。

- 事件

  - event参数，自定义参数

    1.event是原生的event对象，没有经过任何的装饰

    2.事件被挂载到当前元素

  - 事件修饰符，按键修饰符

    ![](..\picture\事件修饰符.png)

    ![](..\picture\按键修饰符.png)

  - 【观察】事件 被绑定到哪里？

- 表单

  - v-model

    `<textarea v-model="desc"></textarea>`

    注意：`<textarea>{{desc}}</textarea>`是不允许的

  - 常见的表单项 textarea checkbox radio select

  - 修饰符 lazy number trim

### Vue组件使用

- props 和 $emit（父子组件之间的通讯）

  ```js
  props: {
      list: {
          type: Array,
          default() {
              return []
          }
      }
  }
  ```
  ```js
  this.$emit(事件方法, 值)
  ```

- 组件间通讯 - 自定义事件（组件之间没有关系或者层级比较深）

  ```js
  import event from './event.js'
  event.$emit(事件方法, 值)
  ```
  ```js
  // 及时解绑自定义事件
  beforeDestory() {
      // 及时销毁，否则可能造成内存泄漏
      event.$off('onAddTitle', this.addTitleHandler)
  }
  ```

  event.js

  ```js
  import Vue from 'vue'
  
  export default new Vue()
  ```

  

- 组件生命周期

  - 单个组件

    created  页面还没开始渲染，但Vue实例已经初始化完成

    mounted  页面渲染完成  基本情况在mounted中进行操作，如ajax获取信息，绑定事件等

    beforeDestroy  解除绑定，销毁子组件以及事件监听器     如自定义事件，setTimeout，window、document事件

  - 父子组件

    父组件先开始初始化，再子组件初始化，子组件渲染完成后，父组件才渲染完成

    index created

    list created

    list mounted

    index mounted

    父组件先开始进入更新状态，再子组件，子组件更新完成后，父组件才更新完成

    index beforeUpdate

    list beforeUpdate

    list updated

    index updated

    销毁destroy同理

### Vue高级特性

- 自定义v-model（如颜色选择）

  index.Vue

  ```vue
  <template>
      <p>{{name}}</p>
      <CustomVModel v-model="name" />
  </templete>
  <script>
  import CustomVModel from './CustomVModel'
  export default{
  	components: {
      	CustomVModel
  	},
      data() {
          return() {
              name: 'csm'
          }
      }
  }
  </script>
  ```

  CustomVModel.Vue

  ```vue
  <template>
      <!--	
          注意：
          1.input使用:value而不是v-model
          2.change和model.event要对应起来
          3.content属性对应起来
      -->
      <input type="text" :value="content" @input="$emit('change', $event.target.value)">
  </templete>
  <script>
  export default{
  	model: {
      	prop: 'content',
          event: 'change'
  	},
      props:{
          content: String,
          default() {
              return ''
          }
      }
  }
  </script>
  ```

- $nextTick，ref

  - Vue是异步渲染
  - data改变之后，DOM不会立刻渲染
  - $nextTick会在DOM渲染之后被触发，以获取最新DOM节点

  ```vue
  <template>
  	<div>
          <ul ref="ul1">
              <li v-for="(item, index) in list" :key="index">{{item}}</li>
          </ul>
          <button @click="addItem">
              添加一项
          </button>
      </div>
  </template>
  <script>
      data() {
          return {
              list: ['a', 'b', 'c']
          }
      },
          methods: {
              addItem() {
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  // 1.异步渲染，$nextTick待DOM渲染完后再回调
                  // 2.页面渲染时会将data的修改做整合，多次data修改只会渲染一次
                  this.$nextTick(() => {
                      const ulElem = this.$refs.ul1
                      console.log(ulElem.childNodes.length)   
                      // 点击后 6，如果没有$nextTick是3
                  })
              }
          }
  </script>
  ```

- slot

  没有插槽的情况下在组件标签内写一些内容是不起任何作用的，当在组件中声明了slot元素后，在组件元素内写的内容就会替换slot。

  用于父组件中往子组件中插入一段内容。

  - 基本使用

    index.vue

    ```vue
    <template>
    	<SlotDemo :url="website.url">
        	{{website.title}}
        </SlotDemo>
    </template>
    ```

    SlotDemo.vue

    ```vue
    <template>
    	<a :href="url">
            <slot>
                默认内容，即父组件没设置内容时，这里显示
            </slot>
        </a>
    </template>
    ```

  - 作用域插槽

    index.Vue

    ```vue
    <template>
    	<ScopedSlotDemo :url="website.url">
        	<template v-slot="slotProps">
    			{{slotProps.slotData.title}}
    		</template>
        </ScopedSlotDemo>
    </template>
    ```

    ScopedSlotDemo

    ```vue
    <template>
    	<a :href="url">
            <slot :slotData="data">
                {{data.name}}
            </slot>
        </a>
    </template>
    ```

  - 具名插槽

    index.Vue

    ```vue
    <template>
    	<NamedSlot>
            <!-- 缩写 <template #header> -->
            <template v-slot:header>
            	<h1>将插入header slot中</h1>
            </template>
    		<p>将插入到main slot中，即未命名的slot</p>
    		<template v-slot:footer>
            	<h1>将插入footer slot中</h1>
            </template>
        </NamedSlot>
    </template>
    ```

    NamedSlot.Vue

    ```vue
    <template>
    	<div>
            <header>
            	<slot name="header"></slot>
            </header>
            <main>
            	<slot></slot>
            </main>
            <footer>
            	<slot name="footer"></slot>
            </footer>
        </div>
    </template>
    ```

- 动态组件

  - 用法 `<component:is="component-name" />` 
  - 需要根据数据，动态渲染的场景，如常见的有文本，视频，图片组件的新闻详情页。即组件类型不确定。

- 异步组件

  - import()函数

    同步引入组件：`import formDemo from './formDemo'`

    异步引入组件：

    ```vue
    components:{
    	formDemo: () => import('./formDemo')
    }
    ```

  - 按需加载，异步加载大组件

- keep-alive

  ```vue
  <keep-alive>
  	<KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
  </keep-alive>
  ```

  - 缓存组件
  - 频繁切换，不需要重复渲染，用于tab切换等
  - Vue常见性能优化

- mixin

  mixin.js

  ```js
  export default {
      data() {
          return {
              city: ''
          }
      },
      methods: {
          showName() {
              console.log(this.name)
          }
      }
  }
  ```

  index.Vue

  ```vue
  <script>
  import myMixin from './mixin'
  export default {
      mixins: [myMixin], // 可以添加多个，会自动合并起来
      data() {
          return {
              name: ''
          }
      },
      methods: {
      }
  }
  </script>
  ```

  - 多个组件有相同逻辑，抽离出来
  - mixin并不是完美的解决方案，会有一些问题
    - 变量来源不明确，不利于阅读
    - 多mixin可能造成命名冲突
    - mixin和组件可能出现多对多的关系，复杂度较高
  - Vue3提出的Composition API旨在解决这些问题

### Vuex使用

- 用于Vue组件

  - dispatch
  - commit
  - mapState
  - mapGetters
  - mapActions
  - mapMutations

- actions中才能做异步操作，不能在mutations中做

  ![vux过程](..\picture\vux过程.png)

### Vue-router使用

- 路由模式（hash，H5 history）

  - hash模式（默认），如 http://abc.com/#/user/10
  - H5 history模式，如 http://abc.com/user/20
  - 后者需要server端支持，因此无特殊需求可选择前者

- 路由配置（动态路由，懒加载）

  - 动态路由

    ```js
    const User = {
        template: '<div>User {{ $route.params.id }}</div>'
    }
    
    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头 能命中'/user/20','/user/10'等格式的路由
            { path: '/user/:id', components: User }
        ]
    })
    ```

  - 懒加载

    ```js
    const router = new VueRouter({
        routes: [
            { 
                path: '/user/:id', 
                // 异步加载组件
                components: () => import('./../components/Navigator')
            }
        ]
    })
    ```

    

## Vue原理

### 组件化基础

- “很久以前”就有组件化
- 数据驱动视图（MVVM，setState）

### 响应式

- 组件data的数据一旦变化，立刻触发视图更新

- 核心API - Object.defineProperty

  - 基本用法

    `Object.defineProperty(obj, props, descriptor)`
  
    作用： 在对象上定义一个新属性或者修改原有属性
  
    返回值： 修改后的目标对象obj
  
    参数定义：
  
    - obj: 在其上定义或修改属性的目标对象
  
  
    - props: 属性名称
  

    - descriptor: 属性描述符
  
  
    ```js
    const data = {}
    const name = 'zhangsan'
    Object.defineProperty(data, "name", {
        get: function() {
            console.log('get')
            return name
        },
        set: function() {
            console.log('set')
            name = newVal
        }
    })
    
    // 测试
  console.log(data.name) // get zhangsan
    data.name = 'lisi'     // set
    ```
  
  - 如何深度监听data变化（简单实现）
  
    ```js
    function updateView() {
        console.log('视图更新')
    }
    function defineReactive(target, key, value) {
        // 深度监听
        observe(value)
        // 核心API
        Object.defineProperty(target, key, {
            get() {
                return value
            },
            set(newValue) {
                if (newValue !== value) {
                    // 设置新值
                    observe(newValue)
                    value = newValue
                    // 触发更新视图
                    updateView()
                }
            }
        })
    }
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            // 不是对象或数组
            return target
        }
        // 重新定义各个熟悉（for in也可以遍历数组）
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    
    const data = {
        name: 'zhangsan',
        age: 20,
        info: {
            address: 'beijing' // 需要深度监听
        }
    }
    
    data.info.address = 'shanghai'
    ```
  
  - 如何监听数组变化
  
    ```js
    // 重新定义数组原型
    const oldArrayProperty = Array.propertype;
    // 创建新对象，原型指向oldArrayProperty，在扩展新的方法不会影响原型
    const arrProto = Object.create(oldArrayProperty);
    ['push', 'pop', 'shift', 'splice'].forEach(methodName = arrProto[methodName] = function () {
        updateView() //触发视图更新
        oldArrayProperty[methodName].call(this, ...arguments)
        // 比如 这个新对象有push方法，则先实现他自己定义的push方法
        // 然后再处理原型数组的push方法  
        // 即 Array.prototype.push(this, ...arguments)
    })
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            return target
        }
        // 监听数组
        if (Array.isArray(target)) {
            target.__proto__ = arrProto
        }
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    ```
  
  - 一些缺点（Vue3.0启用Proxy）
  
    - 深度监听需要递归到底，一次性计算量大
    - 无法监听新增/删除属性（Vue.set Vue.delete）
    - 无法原生监听数组，需要特殊处理
  
  - Proxy有兼容性问题，且无法polyfill

### vdom和diff

### 模板编译

### 组件渲染过程

### 前端路由



## React使用

### React基本使用

- JSX语法
  - 变量、表达式

    我们可以在JSX中使用JS表达式（不能适用于语句），表达式写在大括号“{}”中

    - `{2+2}`  `{user.firstName}`  `{formatName(user)}`

    - 在JSX中不能使用if-else语句，但可以使用conditional（三元运算）表达式来替代

      ```js
      const show = true;
      {show ? <img src="xxx.png"/> : ''}
      ```

    - 循环

      ```js
      const list = [1, 2, 3, 4, 5];
      {
          list.map((item, index) => {
              return <li key={index}>{item}</li>
          })
      }
      ```

  - class style

    - React推荐使用内联样式。我们可以使用camelCase语法设置内联样式。

      React会在指定元素数字后自动添加px

      ```js
      var myStyle = {
          fontSize: 100,  // css中为font-size
          color: '#FF0000'
      };
      <h1 style={myStyle}>xxx</h1>
      ```

    - ```js
      <h1 style = {{background: red;}}>xxx</h1> //两个大括号
      ```

    - ```js
      .red-btn {
          background: red;
      }
      <h1 className='red-btn'>xxx</h1>  // 使用className而不是class
      ```

  - 原生HTML

    ```js
    var item = `<h1>hello</h1>`
    <li
    	key={index}
    	onClick={this.handleItemDelete.bind(this, index)}
        dangerouslySetInnerHTML={__html: item}
    >
    </li>
    ```
  ```
  
  ```
  
- 子元素和组件
  
- 条件渲染

  - if else

    ```js
    const whiteBtn = <button className="btn-white">white btn</button>
    const blackBtn = <button className="btn-black">black btn</button>
    
    if (this.state.theme === 'black') {
        return blackBtn
    } else {
        return whiteBtn
    }
    ```

  - 三元表达式

    ```js
    return <div>
        { this.state.theme === 'black' ? blackBtn : whiteBtn }
    </div>
    ```

  - 逻辑运算符 &&  ||

    ```js
    return <div>
        { this.state.theme === 'black' && blackBtn }
    </div>
    ```

- 列表渲染

  - map

    ```js
    class ListDemo extends React.Component {
        constructor(props) {
            super(props)
            this.state = {
                list: [
                    {
                        id: 'id1',
                        title: 'title1'
                    },
                    {
                        id: 'id2',
                        title: 'title2'
                    },
                    {
                        id: 'id3',
                        title: 'title3'
                    }
                ]
            }
        }
        render() {
            return <ul>{this.state.list.map((item, index) => {
                return <li key={item.id}>index {index}; title {item.title}</li>
            })}</ul>
        }
    }
    ```

  - key

- 事件

  - bind this

    ```js
    // 将这种作用域的修改放在constructor中，保证作用域绑定操作只执行一次。
    this.handleBtnClick = this.handleBtnClick.bind(this) //绑定this为对应组件<TodoList/>
    
    <button className="button" onClick={this.handleBtnClick}>提交</button>
    
    handleBtnClick() {
        // console.log(this)  // this默认是undefined
        this.setState({
            inputValue: ''
        })
    }
    
    // 用静态方法，this指向当前实力 不需要再绑定this
    handleBtnClick = () => {
        this.setState({
            inputValue: ''
        })
    }
    ```

  - 关于event参数

    ```js
    handleBtnClick = (event) => {
        event.preventDefault()  // 阻止默认行为
        event.stopPropagation() // 阻止冒泡
        console.log('target', event.target)  // 指向当前元素，即当前元素触发
        console.log('current target', event.currentTarget) // 指向当前元素，假象！
        
        // 注意，event其实是React封装的。可以看__proto__constructor是 SyntheticEvent
        conole.log('event', event)
        
        // 原生event如下。其__proto__constructor是 MouseEvent
        console.log('NativeEvent', event.nativeEvent)
        console.log('NativeEvent target', event.nativeEvent.target) //指向当前元素
        console.log('NativeEvent current target', event.nativeEvent.currentTarget)
    	// 指向document元素
    }
    ```

  - 传递自定义参数

    ```js
    <button className="button" onClick={this.handleBtnClick(id, title)}>提交</button>
    
    handleBtnClick(id, title, event) {
        console.log(id, title)
        console.log('event', event)  // 最后追加一个参数，即可接收event
    }
    ```

- 表单

  - 受控组件
  - input textarea select 用value
  - checkbox radio 用checked

- 组件和props（类型检查）

  - props传递数据
  - props传递函数
  - props类型检查

- state和setState（重点）

  - 不可变值
  - 可能是异步更新
  - 可能会被合并

- 组件生命周期