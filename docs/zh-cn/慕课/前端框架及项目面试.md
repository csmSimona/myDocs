# 前端框架及项目面试

## 面试题

### Vue面试题

- v-show和v-if的区别
- 为何v-for中要用key
- 描述Vue组件生命周期（有父子组件的情况）
- Vue组件如何通讯
- 描述组件渲染和更新的过程
- 双向数据绑定v-model的实现原理

### react面试题

- react组件如何通讯

- JSX本质是什么

- context是什么，有何用途

- shouldComponentUpdate的用途

- 描述redux单向数据流

- setState是同步还是异步（场景见下图）  0 0 1 2 ？

  ![](..\picture\setState异步.png)

### 框架综合应用

- 基于react设计一个todolist（组件结构，redux state数据结构）
- 基于Vue设计一个购物车（组件结构，Vuex state数据结构）

### webpack面试题

- 前端代码为何要进行构建和打包
- module chunk bundle 分别是什么意思，有何区别
- loader和plugin的区别
- webpack如何实现懒加载
- webpack常见性能优化
- babel-runtime和babel-polyfill的区别

## Vue使用

### Vue基本使用

- 插值表达式

- 指令、动态属性

- v-html：会有XSS风险，会覆盖子组件

- computed和watch

  - computed有缓存，data不变则不会重新计算
  - watch如何深度监听？
  - watch监听引用类型，拿不到oldVal

- class和style

  - 使用动态属性
  - 使用驼峰式写法

- 条件渲染

  - v-if v-else 的用法，可使用变量，也可以使用 === 表达式
  - v-if 和 v-show 的区别？
  - v-if 和 v-show 的使用场景？数据改变频繁用 v-show

- 列表渲染

  - 如何遍历对象？也可以用v-for

  - key的重要性，key不能乱写（如random或者index）

  - v-for 和 v-if 不能一起使用

    v-for比v-if的优先级更高，这就说明在v-for的每次循环运行中每一次都会调用v-if的判断，所以不推荐v-if和v-for在同一个标签内同时使用。

- 事件

  - event参数，自定义参数

    1.event是原生的event对象，没有经过任何的装饰

    2.事件被挂载到当前元素

  - 事件修饰符，按键修饰符

    ![](..\picture\事件修饰符.png)

    ![](..\picture\按键修饰符.png)

  - 【观察】事件 被绑定到哪里？

- 表单

  - v-model

    `<textarea v-model="desc"></textarea>`

    注意：`<textarea>{{desc}}</textarea>`是不允许的

  - 常见的表单项 textarea checkbox radio select

  - 修饰符 lazy number trim

### Vue组件使用

- props 和 $emit（父子组件之间的通讯）

  ```js
  props: {
      list: {
          type: Array,
          default() {
              return []
          }
      }
  }
  ```
  ```js
  this.$emit(事件方法, 值)
  ```

- 组件间通讯 - 自定义事件（组件之间没有关系或者层级比较深）

  ```js
  import event from './event.js'
  event.$emit(事件方法, 值)
  ```
  ```js
  // 及时解绑自定义事件
  beforeDestory() {
      // 及时销毁，否则可能造成内存泄漏
      event.$off('onAddTitle', this.addTitleHandler)
  }
  ```

  event.js

  ```js
  import Vue from 'vue'
  
  export default new Vue()
  ```

  

- 组件生命周期

  - 单个组件

    created  页面还没开始渲染，但Vue实例已经初始化完成

    mounted  页面渲染完成  基本情况在mounted中进行操作，如ajax获取信息，绑定事件等

    beforeDestroy  解除绑定，销毁子组件以及事件监听器     如自定义事件，setTimeout，window、document事件

  - 父子组件

    父组件先开始初始化，再子组件初始化，子组件渲染完成后，父组件才渲染完成

    index created

    list created

    list mounted

    index mounted

    父组件先开始进入更新状态，再子组件，子组件更新完成后，父组件才更新完成

    index beforeUpdate

    list beforeUpdate

    list updated

    index updated

    销毁destroy同理

### Vue高级特性

- 自定义v-model（如颜色选择）

  index.Vue

  ```vue
  <template>
      <p>{{name}}</p>
      <CustomVModel v-model="name" />
  </templete>
  <script>
  import CustomVModel from './CustomVModel'
  export default{
  	components: {
      	CustomVModel
  	},
      data() {
          return() {
              name: 'csm'
          }
      }
  }
  </script>
  ```

  CustomVModel.Vue

  ```vue
  <template>
      <!--	
          注意：
          1.input使用:value而不是v-model
          2.change和model.event要对应起来
          3.content属性对应起来
      -->
      <input type="text" :value="content" @input="$emit('change', $event.target.value)">
  </templete>
  <script>
  export default{
  	model: {
      	prop: 'content',
          event: 'change'
  	},
      props:{
          content: String,
          default() {
              return ''
          }
      }
  }
  </script>
  ```

- $nextTick，ref

  - Vue是异步渲染
  - data改变之后，DOM不会立刻渲染
  - $nextTick会在DOM渲染之后被触发，以获取最新DOM节点

  ```vue
  <template>
  	<div>
          <ul ref="ul1">
              <li v-for="(item, index) in list" :key="index">{{item}}</li>
          </ul>
          <button @click="addItem">
              添加一项
          </button>
      </div>
  </template>
  <script>
      data() {
          return {
              list: ['a', 'b', 'c']
          }
      },
          methods: {
              addItem() {
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  this.list.push(`${Date.now()}`)
                  // 1.异步渲染，$nextTick待DOM渲染完后再回调
                  // 2.页面渲染时会将data的修改做整合，多次data修改只会渲染一次
                  this.$nextTick(() => {
                      const ulElem = this.$refs.ul1
                      console.log(ulElem.childNodes.length)   
                      // 点击后 6，如果没有$nextTick是3
                  })
              }
          }
  </script>
  ```

- slot

  没有插槽的情况下在组件标签内写一些内容是不起任何作用的，当在组件中声明了slot元素后，在组件元素内写的内容就会替换slot。

  用于父组件中往子组件中插入一段内容。

  - 基本使用


    index.Vue
    
    ```vue
    <template>
    	<SlotDemo :url="website.url">
        	{{website.title}}
        </SlotDemo>
    </template>
    ```
    
    SlotDemo.Vue
    
    ```vue
    <template>
    	<a :href="url">
            <slot>
                默认内容，即父组件没设置内容时，这里显示
            </slot>
        </a>
    </template>
    ```

  - 作用域插槽

    index.Vue

    ```vue
    <template>
    	<ScopedSlotDemo :url="website.url">
        	<template v-slot="slotProps">
    			{{slotProps.slotData.title}}
    		</template>
        </ScopedSlotDemo>
    </template>
    ```

    ScopedSlotDemo

    ```vue
    <template>
    	<a :href="url">
            <slot :slotData="data">
                {{data.name}}
            </slot>
        </a>
    </template>
    ```

  - 具名插槽

    index.Vue

    ```vue
    <template>
    	<NamedSlot>
            <!-- 缩写 <template #header> -->
            <template v-slot:header>
            	<h1>将插入header slot中</h1>
            </template>
    		<p>将插入到main slot中，即未命名的slot</p>
    		<template v-slot:footer>
            	<h1>将插入footer slot中</h1>
            </template>
        </NamedSlot>
    </template>
    ```

    NamedSlot.Vue

    ```vue
    <template>
    	<div>
            <header>
            	<slot name="header"></slot>
            </header>
            <main>
            	<slot></slot>
            </main>
            <footer>
            	<slot name="footer"></slot>
            </footer>
        </div>
    </template>
    ```

- 动态组件

  - 用法 `<component:is="component-name" />` 
  - 需要根据数据，动态渲染的场景，如常见的有文本，视频，图片组件的新闻详情页。即组件类型不确定。

- 异步组件

  - import()函数

    同步引入组件：`import formDemo from './formDemo'`

    异步引入组件：

    ```vue
    components:{
    	formDemo: () => import('./formDemo')
    }
    ```

  - 按需加载，异步加载大组件

- keep-alive

  ```vue
  <keep-alive>
  	<KeepAliveStageA v-if="state === 'A'" />
      <KeepAliveStageB v-if="state === 'B'" />
      <KeepAliveStageC v-if="state === 'C'" />
  </keep-alive>
  ```

  - 缓存组件
  - 频繁切换，不需要重复渲染，用于tab切换等
  - Vue常见性能优化

- mixin

  mixin.js

  ```js
  export default {
      data() {
          return {
              city: ''
          }
      },
      methods: {
          showName() {
              console.log(this.name)
          }
      }
  }
  ```

  index.Vue

  ```vue
  <script>
  import myMixin from './mixin'
  export default {
      mixins: [myMixin], // 可以添加多个，会自动合并起来
      data() {
          return {
              name: ''
          }
      },
      methods: {
      }
  }
  </script>
  ```

  - 多个组件有相同逻辑，抽离出来
  - mixin并不是完美的解决方案，会有一些问题
    - 变量来源不明确，不利于阅读
    - 多mixin可能造成命名冲突
    - mixin和组件可能出现多对多的关系，复杂度较高
  - Vue3提出的Composition API旨在解决这些问题

### Vuex使用

- 用于Vue组件

  - dispatch
  - commit
  - mapState
  - mapGetters
  - mapActions
  - mapMutations

- actions中才能做异步操作，不能在mutations中做

  ![vux过程](..\picture\vux过程.png)

### Vue-router使用

- 路由模式（hash，H5 history）

  - hash模式（默认），如 http://abc.com/#/user/10
  - H5 history模式，如 http://abc.com/user/20
  - 后者需要server端支持，因此无特殊需求可选择前者

- 路由配置（动态路由，懒加载）

  - 动态路由

    ```js
    const User = {
        template: '<div>User {{ $route.params.id }}</div>'
    }
    
    const router = new VueRouter({
        routes: [
            // 动态路径参数 以冒号开头 能命中'/user/20','/user/10'等格式的路由
            { path: '/user/:id', components: User }
        ]
    })
    ```

  - 懒加载

    ```js
    const router = new VueRouter({
        routes: [
            { 
                path: '/user/:id', 
                // 异步加载组件
                components: () => import('./../components/Navigator')
            }
        ]
    })
    ```

    

## Vue原理

### 组件化基础

- “很久以前”就有组件化
- 数据驱动视图（MVVM，setState）

### 响应式

- 组件data的数据一旦变化，立刻触发视图更新

- 核心API - Object.defineProperty

  - 基本用法

    `Object.defineProperty(obj, props, descriptor)`
  
    作用： 在对象上定义一个新属性或者修改原有属性
  
    返回值： 修改后的目标对象obj
  
    参数定义：
  
    - obj: 在其上定义或修改属性的目标对象
  
  
    - props: 属性名称
  

    - descriptor: 属性描述符
  
  
    ```js
    const data = {}
    const name = 'zhangsan'
    Object.defineProperty(data, "name", {
        get: function() {
            console.log('get')
            return name
        },
        set: function() {
            console.log('set')
            name = newVal
        }
    })
    
    // 测试
  console.log(data.name) // get zhangsan
    data.name = 'lisi'     // set
  ```
  
  - 如何深度监听data变化（简单实现）
  
    ```js
    function updateView() {
        console.log('视图更新')
    }
    function defineReactive(target, key, value) {
        // 深度监听
        observe(value)
        // 核心API
        Object.defineProperty(target, key, {
            get() {
                return value
            },
            set(newValue) {
                if (newValue !== value) {
                    // 设置新值
                    observe(newValue)
                    value = newValue
                    // 触发更新视图
                    updateView()
                }
            }
        })
    }
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            // 不是对象或数组
            return target
        }
        // 重新定义各个熟悉（for in也可以遍历数组）
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    
    const data = {
        name: 'zhangsan',
        age: 20,
        info: {
            address: 'beijing' // 需要深度监听
        }
    }
    
    data.info.address = 'shanghai'
    ```
  
  - 如何监听数组变化
  
    ```js
    // 重新定义数组原型
    const oldArrayProperty = Array.propertype;
    // 创建新对象，原型指向oldArrayProperty，在扩展新的方法不会影响原型
    const arrProto = Object.create(oldArrayProperty);
    ['push', 'pop', 'shift', 'splice'].forEach(methodName = arrProto[methodName] = function () {
        updateView() //触发视图更新
        oldArrayProperty[methodName].call(this, ...arguments)
        // 比如 这个新对象有push方法，则先实现他自己定义的push方法
        // 然后再处理原型数组的push方法  
        // 即 Array.prototype.push(this, ...arguments)
    })
    
    function observe(target) {
        if (typeof target !== 'object' ||target === null) {
            return target
        }
        // 监听数组
        if (Array.isArray(target)) {
            target.__proto__ = arrProto
        }
        for (let key in target) {
            defineReactive(target, key, target[key])
        }
    }
    ```
  
  - 一些缺点（Vue3.0启用Proxy）
  
    - 深度监听需要递归到底，一次性计算量大
    - 无法监听新增/删除属性（Vue.set Vue.delete）
    - 无法原生监听数组，需要特殊处理
  
  - Proxy有兼容性问题，且无法polyfill

### vdom和diff

### 模板编译

### 组件渲染过程

### 前端路由



## React使用

### React基本使用

- JSX语法
  - 变量、表达式
  - class style
  - 子元素和组件
- 条件渲染
- 列表渲染
- 事件
- 组件和props（类型检查）
- state和setState
- 组件生命周期